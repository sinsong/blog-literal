---
title: C++ 语句
date: 2018-07-21 01:40:30
tags:
- C++
---

# 简单语句

C++大多数语句以分号结束，一个表达式，末尾加上分号，就变成了表达式语句(expression statement)。
表达式语句的作用是执行表达式并丢弃掉求值结果。

```C++
ival + 5; //一条没什么实际用处的表达式语句
i = 42;   //一条有用的表达式语句
```

第一条语句没什么用处，虽然执行了加法，但是相加的结果没有使用，然后被丢弃了。
第二条语句在求值时产生副作用，对变量赋值。

## 空语句

最简单的语句是空语句(null statement)，空语句中只有一个单独的分号：

```C++
; //空语句
```

空语句用来占位是不错的选择。有的时候，我们使用流程控制，其控制的语句，我们并不需要执行任何操作。。。

```C++
while (cin >> s && s != sought)
    ; //空语句
```

如果你强行不写占位的话，编译器依然会选择紧挨着while条件的下一个语句作为被控制的语句，参与循环，这也违背了你的意愿。（你写空白是没用的！！！）

> 使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的。

```C++
while (cin >> s && s != sought); //这就是坑人了
...
```

> 多余的空语句并非总是无害的。

## 复合语句（块）

复合语句(compound statement)是指用花括号括起来的（可能为空的）语句和声明的序列，复合语句也被称作块(block)。一个快就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块中访问。
通常，名字在有限的区域内可见，该区域从名字定义处开始，到名字所在的（最内层）块的结尾位置。

如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。

```C++
while (cond)
{
    //这里放多个语句
}
```

> 块不以分号结束。

所谓空块，是指内部没有任何语句的一对花括号。
空块等价于空语句。

```C++
{} //空块
```

# 语句的作用域

可以在控制语句内部定义变量。
定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也超出作用范围。

# 条件语句

按条件执行的语句。
if-else switch

## if 语句

判断一个指定的条件是否为真，根据判断结果决定是否决定另外一条语句。
有两种形式，一种还有else分支，另一种没有。

if语句

if (condition)
    statement

if else语句

if (condition)
    statement
else
    statement2

condition必须用圆括号括起来。
condition是一个表达式，也可以是一个初始化了的变量声明。其类型必须能转换为布尔类型。
通常statement和statement2是块语句。

如果condition为真，执行statement。然后继续执行if语句后面的其他语句。
如果condition为假，跳过statement。对于简单if语句，程序继续执行if语句后面的其他语句；对于if else语句来说，执行statement2，然后跳出if语句。

### 嵌套if语句

if语句可以嵌套

```C++
if (condition1)
{
    //-----------------从这开始
    if (condition2)
    {

    }
    //-----------------到这结束
    //这些都算外层if语句的statement
}
```

C++没有else if的定义，可以看做是一种缩进而已，没有特殊效果，而且不赞成使用。

### 注意使用花括号

如果不用花括号，if语句所控制的statement只是紧挨着condition后面的第一个语句，你再怎么缩进是没用的！！！（这不是Python）。
如果if要控制多个语句，请使用代码块。

### 悬垂else

多个if嵌套，使用else的时候，不清楚else语句和哪个if语句匹配。。。这个问题成为悬垂else(dangling else)。

C++规定else与离他最近的尚未匹配的if匹配。

### 使用花括号

多个if-else语句嵌套，请使用花括号正确嵌套。

## switch语句

提供了一条便利途径使得我们能够在若干固定选项中做出选择。

```C++
switch (expression)
{
case condition1:
    statement1
    ...
    break;
case condition2:
    statement2
    ...
    break;
...
default:
    statement
    ...
    break;
}
```

switch语句首先对括号里的表达式求值，该表达式紧跟在关键字switch后面，可以是一个初始化的变量声明。表达式的值转换为整数类型，然后与每个case标签的值比较。

如果表达式和某个case标签的值匹配成功，程序从该标签之后的第一条语句开始执行，直到到达了switch的结尾或者是遇到一条break语句为止。

break用来中断当前控制流，跳出当前控制流语句。

如果switch语句的表达式和所有case标签都没有匹配上，将直接跳出switch语句。

case关键字和它对应的值一起被称为case标签(case label)。case标签必须是整型常量表达式。
`case 3.14:`就是错误的，不是常量表达式也不行。

### switch内部的控制流

switch语句啊，将表达式与每个case标签进行匹配，如果没有写break语句的话，控制流直接跳转到匹配的case标签，然后往下继续执行。问题是后面再多的case标签也阻挡不了。
case标签只负责将控制流跳转过去，就像goto那样，如果不想执行到其他case标签那里，就要加上break语句，从而跳出switch语句。
加在下一个case标签之前。

然而，有些时候，默认的switch行为也可以是程序需要的。如果我们希望多个值共享一个操作，我们可以故意省略一些break语句，更灵活的编写程序。

```C++
switch (expression)
{
    case cond1:
    case cond2:
    case cond3:
        //do something
        break;
}
```

这样，有多个值都会跳转到那个地方，然后执行相同的代码，再跳出。

C++程序的形式比较自由，所以case标签之后不一定非得换行。
把几个case标签写在一行里也是可以的。

> 一般不要省略case分支最后的break语句。如果没写break语句，最好加一段注释说清楚程序的逻辑。

###漏写break容易引发缺陷

程序只执行匹配成功的那个case分支的语句，是一种错觉！！！
忘记写break的后果是，代码跳转到那个case分支以后，无视case继续向下执行！！！

> 尽管switch语句不是非得在最后一个标签后面写上break，但是为了安全起见，最好这么做。因为这样的话，即使以后再增加新的case分支，也不用再在前面补充break语句了。

### default标签

如果没有任何一个case标签能匹配上switch表达式的值，程序会直接跳出switch语句。
要么，如果有default标签，程序将执行default标签(defalut label)后面的语句。

> 即使不准备在default标签下做任何工作，定义一个default标签也是有用的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么也没做。

标签不应该孤零零的出现，它后面必须跟上一条语句或者另外一个case标签。
如果switch结构以一个空的default标签作为结束，则该default标签后面必须跟上一条空语句或一个空块。

### switch内部的变量定义

敢在switch语句定义变量，就要考虑到switch的执行流程会跨过某些case标签。被跨过的定义语句，就不会执行，该变量不会被定义。使用它就会产生未定义的行为。

# 迭代语句

迭代语句通常称为循环，它重复执行操作直到满足某个条件才停下来。

## while语句

只要条件为真，while语句就重复的执行循环体

while (condition)
    statement

在while语句中，只要condition的求值结果为真就一直执行statement（通常是一个块）。
condition不能为空，如果condition第一次求值就得到false，statement一次也不执行。
每执行一次statement都会重新对condition求值的哟！

while的条件部分可以是一个表达式或者一个带初始化的变量声明。通常来说，应该由条件本身或者是循环体设法改变表达式的值，否则循环可能无法终止。

```C++
while (true)
{
    //这就是个无尽循环哟！
}
```

> 定义在while条件部分或者while循环体内的变量每次迭代都经历创建到销毁的过程。

当不确定到底要迭代多少次时，使用while循环比较合适。

## 传统的for语句

for (init condition expression)
    statement

关键字for及括号里的部分称作for语句头。

init必须是以下三种形式中的一种：
1. 声明语句
2. 表达式语句
3. 空语句
它们都带分号，所以for语句的语法形式也可以看做
for(initializer;condition;expression)
    statement
一般情况下，init负责初始化一个值，这个值将随着循环的进行而改变。
condition作为循环控制的条件，只要condition为真，就执行一次statement。如果第一次的求值结果就是false，则statement一次也不会执行。expression负责修改init初始化的变量，这个变量正好就是condition检查的对象，修改发生在每次循环迭代之后。statement可以是一条单独的语句也可以是一条复合语句。

循环头的设计就是用来简化使用变量控制循环。循环体能更专注的执行其他操作，将循环变量的控制专门写在循环头中，更易理解。

### 传统for循环的执行流程

1. 循环开始时，首先执行一次init。
2. 接下来判断condition。如果为假，跳出循环。如果为真，继续。
3. 如果条件为真，执行循环体。
4. 最后执行expression。然后跳到第2步。

第1步只在循环开始时执行一次。第2,3,4步重复执行直到条件为假时终止。

> 牢记for语句头中定义的对象只在for循环体内可见。

### for语句头中的多重定义

init也可以定义多个对象。但是init只能有一条声明语句。
因此，所有变量的基础类型必须相同。

如果你敢，condition，expression里面可以用逗号运算符，达到执行多个表达式效果。

### 省略for语句头的某些部分

for语句头能省略掉init,condition,expression中的任意个。

如果无需初始化，我们可以用空语句作为init。

省略condition的效果等价于在条件部分写了一个true。因为条件的值永远是true，所以在循环体内必须有语句负责退出循环，否则循环就会无休止的执行下去。

```C++
for (;;)
{
    //无尽循环哟！
}
```

我们也能省略掉for语句头中的expression，但是你就得在其他地方修改循环变量，这也违背了expression设计的初衷。

如果你觉得不需要，省略就省略吧，但是一定要细心的设计循环。

## 范围for语句

C++11 引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。
范围for语句(range for statement)就是为了遍历容器内的元素而设计的。

for (declaration : expression)
    statement

expression表示的必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。（内置数组作为内置类型当然能特殊对待啦）

declaration定义一个变量，序列中的每个元素都得能转换成该变量的类型。确保类型相容最简单的方法就是使用auto类型说明符，这个关键字可以令编译器帮助我们指定合适的类型。如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。

每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行statement。
statement可以是一条单独的语句也可以是一个块。所有元素都处理完毕后循环终止。

范围for语句的定义来源于与之等价的传统for语句

```C++
for (m : a)
{
    //expr(m)
}
for (auto m = a.begin(), e = a.end() ; m != e ; ++m)
{
    //expr(m)
}
```

这样就能好好理解为什么范围for里面不要添加或者删除对象，因为添加删除对象会使迭代器失效。

## do while语句

和while语句类似，区别是，do while语句先执行循环体后检查条件。无论条件的值如何，我们都至少执行一次循环。

do
    statement
while (condition)

do语句中，求condition的值之前首先执行一次statement，condition不能为空。如果condition的值为假，循环终止。否则，重复循环过程。condition使用的变量必须定义在循环体之外。（因为循环体内的变量在对condition求值前被销毁？？？）

因为对于do while来说先执行语句或者块，后判断条件，所以不允许在条件部分定义变量。
变量的使用不能出现在定义之前。

# 跳转语句

跳转语句中断当前执行过程。
C++语言提供了4种跳转语句：break,continue,goto,return。

## break语句

break语句(break statement)负责终止离他最近的while,do while,for,switch语句，并从这些语句之后的第一条语句开始继续执行。

break语句只能出现在迭代语句或者switch语句内部（包括嵌套在此类语句里的语句或块的内部）。break语句的作用范围仅限于最近的循环或者switch。

## continue语句

终止最近的循环中的当前迭代并立即开始下一次迭代。
continue语句只能出现在for,while,do while循环的内部，或者嵌套在此类循环里的语句或块的内部。
continue语句仅作用于离它最近的循环。
（对switch无效）

continue语句中断当前的迭代，但是仍然继续执行循环。（提前结束本次循环体执行么！）
对于while或者do while语句来说，继续判断条件的值。对于传统for循环来说，继续执行for语句头的expression。对于范围for语句来说，则是用序列的下一个元素初始化循环控制变量。

## goto语句

goto语句(goto statement)的作用是从goto语句无条件跳转到同一函数内的另一条语句。

> 不要在程序中使用goto语句，因为它使得程序既难理解又难修改。

语法形式：

goto label;

label是用于标识一条语句的标示符。带标签语句(labeled statement)是一种特殊的语句，它在之前有一个标示符以及一个冒号：

```C++
label: statement; //带标签语句
```

标签标示符独立于变量或其他标识符的名字，因此，标签标示符可以和程序中其他实体的标识符使用同一个名字而不会互相干扰。goto语句和控制权转向的那条带标签的语句必须位于同一个函数之内。

goto跳过的变量声明，无法使用！

跳过一个已经执行的定义是合法的。跳回到变量定义之前意味着该变量会被销毁，然后重新创建它。

# try语句块和异常处理

异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一部分。

当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时，检测出问题的部分应该发出某种信号以表明程序遇到了故障，无法继续下去了，而且信号的发出方无需知道故障将在何处得到解决。一旦发出异常信号，检测出问题的部分也就完成了任务。

如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。

异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言中，异常处理包括：
* throw表达式(throw expression)，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发(raise)了异常。
* try语句块(try block)，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句(catch clause)结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以他们也被称作异常处理代码(exception handler)。
* 一套异常类(exception class)，用于在throw表达式和相关的catch子句之间传递异常的具体信息。

## throw表达式

程序的异常检测部分用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。

```C++
throw runtime_error("这个程序觉得哪里有问题。");
```

## try语句块

try
{
    program-statements
}
catch (exception-declaration)
{
    handler-statements
}
catch (exception-declaration)
{
    handler-statements
}//...

try语句块的一开始是关键字try，随后紧跟着一个块，这个块就像大多数时候那样是花括号括起来的语句序列。

跟在try块之后的是一个或多个catch子句。catch子句包括三部分：关键字catch、括号内一个（可能未命名的）对象的声明（称作异常声明(exception declaration)）以及一个块。当选中某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。

try语句块中的program-statements组成程序的正常逻辑，像其他任何块一样，program-statements可以有包括声明在内的任意C++语句。try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。

### 函数在寻找处理代码的过程中退出

在复杂系统中，程序在遇到抛出异常的代码之前，其执行路径可能已经经过了多个try语句块。

寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，知道找到适当类型的catch子句为止。

如果最终还是没找到任何匹配的catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。

对于那些没有任何try语句块定义的异常，也按照类似的方式处理：毕竟，没有try语句块也意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。
