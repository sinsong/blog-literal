---
title: C++ 内置数组
date: 2018-07-19 16:25:16
tags:
- C++
---

数组是存放类型相同对象的容器，这些对象本身没有名字。数组的大小不变，不能随意向数组添加元素。

# 定义和初始化内置数组

数组是一种复合类型。
数组的声明形式是：a[d]，其中a是数组的名字，d是数组的形状，[]的个数是数组的维度。
d说明了数组中元素的个数，必须大于0.
数组中元素的个数属于数组类型的一部分，编译的时候应该是已知的，也就是说，d应该是一个常量表达式。
（这里有争议）

```C++
unsigned cnt = 42; //不是常量表达式
constexpr unsigned sz = 42; //常量表达式
int arr[10]; //含有10个整数的数组
int *parr[sz]; //含有42个整型指针的数组
string bad[cnt]; //错误：cnt不是常量表达式
string strs[get_size()]; //当get_size是constexpr时正确，否则错误
```

默认情况下，数组的元素被默认初始化。

> 和内置类型的变量一样，定义在函数体内部的某种内置类型的数组，未初始化！

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。
数组的元素应该为对象，因此不存在引用的数组。

## 显式初始化数组元素

可以对数组的元素进行列表初始化，此时允许忽略数组的形状。
编译器可以根据初始值的数量推导。
如果指明了形状，初始值的总数量不应超出指定大小。
如果数量不够，初始化靠前的元素，不足的默认初始化。

```C++
const unsigned sz = 3;
int ia1[sz] = {0,1,2}; //含有3个元素的数组
int a2[] = {0,1,2}; //三个元素的数组
int a3[5] = {0,1,2}; //等价于a3[] = {0,1,2,0,0}
string a4[3] = {"hi", "bye"}; //等价于a4[] = {"hi", "bye", ""}
int a5[2] = {0,1,2}; //错误：初始值过多
```

## 字符数组的特殊性

字符串就是字符数组！！！
用字符串字面值初始化字符数组的时候，注意每个字符串的末尾有个空字符(`\0`)！！！
空字符用来表示字符串的结束！！！
这个空字符由编译器自动添加，所以应该留一个位置！
这是一个约定，你可以绕过，不过会受到惩罚！

```C++
char a1[] = {'C', '+', '+'}; //列表初始化，没有空字符，不提倡！！！
char a2[] = {'C', '+', '+', '\0'}; //列表初始化，含有显式的空字符
char a3[] = "C++"; //自动添加表示字符串结束的空字符
const char a4[6] = "Daniel"; //错误：没有空间可存放空字符
```

## 不允许拷贝和赋值

不能直接用数组的名字作为其他数组的初始值，也不能给其他数组赋值。

```C++
int a[] = {0,1,2};
int a2[] = a; //错误：不能用于初始化
a2 = a; //错误：不能赋值
```

> 一些编译器支持数组的赋值，这就是所谓的编译器扩展(compiler extension)。一般来说，最好避免使用非标准特性，因为可移植性会降低

## 理解复杂的数组声明

那就从内向外阅读吧！

```C++
int *ptrs[10]; //含有10个整型指针的数组
int &refs[10] = /*???*/ //错误：不存在引用的数组
int (*Parray)[10] = &arr; //Parray指向一个含有10个整数的数组
int (&arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组
```

默认情况下，类型修饰符从右向左生效。
但是对于Parray来说，应该从内向外阅读。
首先是圆括号括起来的部分，*Parray表示Parray是一个指针，接下来观察右边，得知Parray指向一个数组，大小为10，然后观察左边，得知数组的元素是int类型。这下就明了了。

# 访问数组元素

数组元素能用范围for，下标，来访问。数组的索引从0开始。
使用下标时，通常定义为size_t类型。
size_t类型是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小。
定义在`<cstddef>`。

数组的形状是数组类型的一部分，所以编译器知道数组元素的个数，使用范围for语句能减轻人为控制遍历过程的负担。

```C++
int a[10] = {0,1,2,3,4,5,6,7,8,9};
for (auto m : a)
{
    //这里使用m
}
```

然而传统方法是这样：

```C++
constexpr size_t nmem = 100;
int a[nmem]; //注意没有初始化，不要使用它的值

for(int c = 0; c < nmem ; ++c) //注意是小于号！！！a[nmem]元素不存在！！！下标从0开始！！！
{
    a[c] = 0; //这里给每个元素赋值
}
```

## 检查下标的值

数组的下标是否在合理范围之内，由程序员负责检查，下标应该大于等于0而且小于数组的大小。
要想防止数组下标越界，除了小心谨慎注意细节以及对代码进行彻底的测试之外，没有好办法。
对于一个程序来说，即使顺利通过编译并执行，也不能肯定不包含此类致命的错误。

> 大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。

# 指针和数组

可以对数组元素取地址

```C++
int a[3] = {0,1,2};
int *p = &a[0];
```

在用数组名字的时候，编译器可以隐式转换成指向数组首元素的指针。

```C++
int *p = a; //等价于 p = &a[0]
```

> 大多数表达式中，直接使用数组会隐式转换为数组首元素的指针。

一些情况下数组的实际操作是指针操作。
当数组作为一个auto变量的初始值的时候，推断得到的类型是指针而非数组

```C++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia); //ia2是一个整型指针，指向ia的首元素
ia2 = 42; //错误，ia2是指针
```

实际初始化就像`auto ia2(&ia[0]); //显然得出ia2->int*`

然而使用decltype关键字，这种转换就不会发生。
decltype(ia)返回一个10个整型构成的数组。

## 指针也是迭代器

指向数组元素的指针可以通过递增运算符移动到下一个位置上。

```C++
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr; //p -> arr[0]
++p; //p -> arr[1]
```

我们可以设法获取数组那个不存在的元素，尾后指针的地址。

```C++
int *e = &arr[10]; //指向arr尾元素下一位置的指针，尾后指针
```

尾后指针指向的是一个不存在的元素，只能拿来比较，不能访问，不能解引用！不要对其递增。

利用上面的首元素指针和尾后指针，我们可以将指针当做数组的迭代器用

```C++
for(int *b = arr; b != e; ++b)
{
    //这里访问*b就行
}
```

## 标准库函数begin和end
尽管计算能得到尾后指针，但是很容易出错。
为了让指针的使用更简单，更安全，C++11引入begin和end的函数。
将数组作为他们的参数，就能得到类似迭代器的东西哟！

```C++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
int *b = begin(ia);
int *e = end(ia);
```

b就是首元素指针啦，e就是尾后指针啦。
这两个函数定义在`<iterator>`

## 指针运算

指针加上，或者减去一个整数值，得到一个新指针，相比原来那个指针，向下几个位置，或者想上几个位置移动该整数个位置。
指针移动假设对象紧邻存储，步长由指针的类型提供。

```C++
int a[] = {0,1,2,3,4,5};

int *p = a; //p -> a[0]
int *p2 = p + 2; //p2 -> a[2]
```

如果你知道数组的大小，这么获取尾后指针也很简单。

```C++
int a[6] = {0,1,2,3,4,5};
int *e = a + 6; //对，直接加上数组的元素个数就行
```

移动指针的时候一定要注意！移动指针更容易越界访问哟！！！
而且这种错误，编译器也帮不了你！

两个指针相减的结果就是他们的距离。参与运算的指针必须指向同一个数组的元素，不然该结果无意义。
结果是一种名为ptrdiff_t的类型，定义在`<cstddef>`的机器无关的类型。
因为差值可能为负，所以是一种带符号类型。

空指针也能参与运算，不过限制较大。。。
空指针只能加减0，两空指针相减，结果是0。

尾后指针减去首元素指针，得到数组大小哟！

## 解引用和指针运算的交互

指针加减整数来移动，如果确实指向对象，则可以解引用。

```C++
int ia[] = {0,1,2,3,4,5};
int last = *(ia + 5); //正确，也就是初始化为ia[5]
```

注意括号，*的优先级比较高，不加括号的话，就变成了
`last = *ia + 4; //正确，但是成了ia[0] + 4`
含义就不一样了。。。

## 下标和指针

也许你已经发现了。
使用数组的名字，其实用的是指向数组首元素的指针。（隐式转换哟！）
对数组使用下标运算符时，编译器会自动执行转换，其实是对指向数组首元素的指针执行下标运算。

```C++
int ia[] = {0,1,2,3,4,5};

int i = ia[2];

int *p = ia; //p -> ia[0]
i - *(p + 2); //等价于 i = ia[2]
//2来自下标哟！
```
只要指针是数组中的元素（或者尾后），都可以执行下标运算。

```C++
int *p = &ia[2]; //p -> ia[2]
int j = p[1]; //p[1] 等价于 *(p+1)， 就是ia[3]
int k = p[-2]; //p[-2]是ia[0]表示的元素
```

内置的下标运算和标准库的不一样。
内置的会更狂野一点，内置的下标运算能处理负值（往上移动么），不过，小心越界！
标准库的下标运算符限定使用的下标必须是无符号类型，内置的就没这个要求，当然，小心越界。

这你应该明白为啥下标要从0开始了吧。

a[0] -> a + 0
a[1] -> a + 1
a[n] -> a + n

内置下标运算就是这么狂野！

# 多维数组

严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记！

当一个数组的元素仍然是数组是，通常用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）的大小。

```C++
int ia[3][4];
//大小为3的数组，其元素都是含有4个整数的数组

int arr[10][20][30] = {0}; //将所有元素初始化为0
```

这声明也是由内向外理解较好。

对于二维数组来说，常把第一个维度称作行，第二个维度称作列。

## 多维数组的初始化
允许使用列表初始化，然后将花括号连同其中元素一起作为另一个数组的元素。
嵌套一下就行。

```C++
int ia[3][4] = {
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};
```

嵌套也不是必须的，下面的功能一样

```C++
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

类似的，可以少初始化几个。

```C++
int ia[3][4] = {{0}, {4}, {8}}; //显式地初始化每行的首元素
```

未列出的元素执行默认初始化。
大括号嵌套去掉的话，含义就变了。数组会被平铺的初始化。

## 多维数组的下标引用

一层层剥么。。。

使用下标访问数组的数组，会得到内层数组。

遍历多维数组的话，就用多个for嵌套来控制下标访问。

```C++
constexpr int s1 = 3, s2 = 4, s3 = 5;
int ia[s1][s2][s3];

for (size_t i = 0; i < s1; ++i)
{
    for (size_t j = 0; j < s2; ++j)
    {
        for (size_t k = 0; k < s3; ++k)
        {
            ia[i][j][k] = 0; //给每个元素赋值为0
        }
    }
}
```

## 使用范围for语句处理多维数组

C++11新增了范围for语句，然后程序可以简化。

```C++
constexpr int s1 = 3, s2 = 4, s3 = 5;
int ia[s1][s2][s3];

for (auto &i : ia)
{
    for (auto &j : i)
    {
        for (auto &k :j)
        {
            k = 0; //给每个元素赋值为0
        }
    }
}
```

外层循环的控制变量必须是引用类型，避免数组被自动转换成指针。
如果不用引用，程序编译不会通过。。。因为无法遍历一个指针。。。

> 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

## 指针和多维数组

多维数组的名字也可以隐式转换为指向该数组首元素的指针。

> 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。

多维数组名字隐式转换为指向第一个内存数组的指针，这个指针指向一个数组哟！

```C++
int ia[3][4];
int (*p)[4] = ia; //p -> ia[0] | p指向一个含有4个整数的数组
p = &ia[2];
```

p的声明从内往外读哟。圆括号用来消除歧义。`int *p[4];`就是整型指针的数组了。

使用auto或者decltype能简化声明

```C++
for (auto p = ia; p != ia + 3; ++p)
{
    for (auto q = *p; q != *p + 4; ++q)
    {
        cout<<*q<<' ';
    }
}
```

使用标准库函数begin和end更简洁些

```C++
for (auto p = begin(ia); p != end(ia); ++p)
{
    for (auto q = begin(*p); q != end(*p); ++p)
    {
        cout<< *q <<' ';
    }
}
```

## 类型别名简化多维数组的指针

```C++
using int_array = int[4];
typedef int int_array[4];

for(int_array *p = ia; p != ia + 3; ++p)
{
    for(int *q = *p; q != *p + 4; ++q)
    {
        cout<< *q << ' ';
    }
}
```

