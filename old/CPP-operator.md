---
title: C++ 运算符重载和类型转换
date: 2018-08-14 20:40:41
tags:
- C++
---

# 基本概念

重载的运算符是具有特殊名字的函数：他们的名字由关键字operator和其后要定义的运算符号共同组成。

重载运算符函数的参数数量与该运算符作用的运算对象一样多。
除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。

如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符的（显式）参数数量比运算符的运算对象总数少一个。

> 当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。

对于一个运算符函数来说，它或者时类的成员，或者至少含有一个类类型的参数。
意味着当运算符作用于内置类型的运算对象时，我们无法改变运算符的含义。

我们只能重载已有的运算符，而无权发明新的运算符号。

对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。

可以被重载的运算符：
```C++
+ - * / % ^
& | ~ ! , =
< > <= >= ++ --
<< >> == != && ||
+= -= /= %= ^= &=
|= *= <<= >>= [] ()
-> ->* new new[] delete delete[]
```

不能被重载的运算符
```C++
:: .* . ?:
```

### 直接调用一个重载的运算符函数

通常，我们将运算符作用于类型正确的实参，从而间接方式“调用”重载的运算符函数。
然而，我们也能像普通函数一样直接调用运算符函数。

```C++
//一个非成员运算符函数的等价调用
data1 + data2; //普通的表达式
operator+(data1, data2); //等价的函数调用
```

成员函数就使用点运算符（或者箭头运算符）。

```C++
data1 += data2; //基于“调用”的表达式
data1.operator+=(data2); //对成员运算符函数的等价调用
```

### 某些运算符不应该被重载

重载无法保证短路求值属性。。。不建议重载。

逗号和取地址符，不应该被重载，否则他们的行为将异于常态，从而导致类的用户无法适应。

> 通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。

### 使用与内置一致的含义

* 如果类执行IO操作，则定义移位运算符使其与内置类型的IO保持一致。
* 如果类的某个操作是检查相等性，则定义operator==;、；如果类有了operator==，意味着它通常也应该有operator!=。
* 如果类包含一个内在的单序比较操作，则定义operator<；如果类有了operator<，则它也应该含有其他关系操作。
* 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用。

### 赋值和复合赋值运算符

赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。重载的赋值运算应该继承而非违背其内置版本的含义。

如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符。
+=运算符的行为显然应该与其内置版本一致，即先执行+，再执行=。

### 选择作为成员或者非成员

当我们定义重载的运算符时，必须首先决定是将其声明为成员函数还是声明为一个普通的非成员函数。再某些时候我们别无选择，因为有的运算符必须作为成员；
另一些情况下，运算符作为普通函数比作为成员更好。

准则：
* 赋值=、下标[]，调用()和成员访问箭头->运算符必须是成员。
* 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。
* 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。
* 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符，因此他们通常应该是普通的非成员函数。

当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。

# 输入和输出

```C++
ostream &operator<<(ostream &os, const T &a)
{
    ...
    return os;
}
```

应该尽量减少格式化操作。
>通常，输出运算符应该主要负责打印对象的内容而非控制格式。

输入输出必须是非成员函数。
IO运算符一般声明为友元。

```C++
istream &operator>>(istream &is, T &a)
{
    ...
    return is;
}
```

如果发生了IO错误，则运算符将给定的对象重置为空，这样可以确保对象处于正确的状态。

> 输入运算符必须处理可能失败的情况，而输出运算符不需要。

> 当读取操作发生错误时，输入运算符应该负责从错误中恢复。

# 算术和关系运算符

```C++
T operator+(const T &lhs, const T &rhs)
{
    T ret = ...;
    return ret;
}
```

> 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值运算符类实现算术运算符。

