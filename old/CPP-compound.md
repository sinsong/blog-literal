---
title: C++ 复合类型
date: 2018-07-14 13:56:01
tags:
- C++
---

复合类型(compound type)是基于其他类型定义的类型。

一条声明语句由一个基本数据类型(base type)和紧随其后的一个声明符(declarator)列表组成。每个声明符声明了一个变量并指定该变量为与基本数据类型有关的某种类型。

我：声明符在基本数据类型的基础上再做修饰，“派生”出新的类型。

# 引用

> C++ 11中新增了一种引用：所谓的右值引用(rvalue reference)。一般的“引用(reference)”指的是“左值引用(lvalue reference)”。

引用(reference)是对象的别名，引用类型引用(refers to)另外一种类型。
引用使用 &var 形式的声明符，其中var是变量名。
定义引用时，引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。无法令引用重新绑定到另一个对象，因此引用必须初始化。

我：初始化和赋值本来就是不一样的。引用初始化时绑定对象，对他的所有操作等价于操作绑定的对象，对引用赋值是在对引用绑定的对象赋值。并不存在重新绑定的语法。。。引用在初始化绑定，所以引用必须初始化。

```C++
int i = 42; //一切的答案

int &r = i; //r作为引用绑定到i。

int &r2; //错误！引用必须初始化！！！
```

## 引用即别名

> 引用并非对象，它只是一个已经存在的对象的别名。

定义一个引用以后，操作引用等价于操作绑定的对象。

```C++
r = 1024; //这里赋值，操作的是变量i。
```

引用作为初始值，实际上是绑定的是那个引用所绑定的对象。

```C++
int &r3 = r;
//因为r -> i，r3使用r初始化，结果：r3 -> i。
```

## 引用的定义

允许在一条语句中定义多个引用，不过每个引用的声明符都要带上&

```C++
int a = 1, &b = a;
//a是int变量，b才是引用。
```

引用必须与所绑定的对象类型严格匹配，除过两种例外情况。
引用只能绑定在对象上（左值），不能与字面值，表达式计算结果绑定，因为那是右值。

# 指针

指针(pointer)是指向(point to)另外一种类型的符合类型。
与引用相似，指针也实现了对其他对象的间接访问。
不一样的是：
1. 指针本身就是一个对象。允许对指针赋值和拷贝，在生命周期内可以指向不同的对象。
2. 指针无需在定义时赋初值（语法上而已）。和其他内置类型一样，在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。

我：指针定义时确实可以不初始化，不过这么做就会有野指针的风险，访问野指针是很危险的，不初始化可能会拥有不确定的值，如果访问了不该访问的地方，系统会艹你的程序的。一般是初始化为空指针，即字面值`nullptr`，不过一定要判断一下，不然，解引用空指针的后果就可能是：0x00000000该内存不能为read。这地址属于系统。。。

> 指针通常难以理解（哦？是吗？）即使是有经验的程序员也尝尝因为调试指针引发的错误而备受折磨。

定义指针类型的方法是将声明符写成 *p 的形式，其中p是变量名。
如果在一条声明语句中定义多个指针，每个指针声明符都要记得有*。
我：* 符号要是手抖多写了几个可不好。应为`*p`,`**p`,`***p`都是不同的类型。

```C++
int i = 0, *p; //i是变量，p是指针。
```

## 获取对象的地址

使用指针，先使指针指向一个对象。
指针通过存放一个对象的地址来指向那个对象，要想获取对象的地址，需要使用取地址符（操作符&）。

```C++
int i = 42;
int *p = &i;  //p存放i的地址，现在p指向变量i了
```

What？&不是引用吗？不，你看看&出现的位置，它出现在表达式中！！！引用中的&是写在声明符中的，不同的位置拥有不同的含义哟！

指针类型必须与指向的对象的类型严格匹配，除过两种例外情况。

```C++
double d = 3.14;
double *pd = &d; //pd是指向d的指针。
int *pi = &d; //错误：类型不匹配。
int *pi2 = pd; //错误：类型不匹配
```

声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以两者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

我：通过指针访问对象时，只知道对象的地址。而对象的尺寸是未知的，需要指针的类型提供指向对象的尺寸，如果真的敢指向其他类型的对象，后果自负。而且指针的移动也得由类型提供移动的步长。

## 指针值

指针的值（即地址）应属于下列4中状态之一：
1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，表示着指针没有指向任何对象。
4. 无效指针，也就是上述情况之外的其他值。

试图使用无效指针的值很可能引发错误。编译器不负责检查此类错误（它也检查不了），这和未经初始化的变量是一样的（变量顶多影响程序，指针可以影响系统，然后系统发现，艹你的程序）。访问无效指针的后果无法语句，因此程序员必须清楚任意给定的指针是否有效。

第二种和第三种情况的指针尽管是有效的，但是使用受到限制。这些指针显然也没有指向任何具体对象，不要试图访问此类指针指向的“对象”。
这种指针是用来判断和比较的。
紧邻对象空间的下一个位置，用来判断一个数组的末尾的。。。
空指针的值是用来表示：我不指向任何对象。
解引用空指针将会得到错误。

## 利用指针访问对象

如果指针指向了一个对象，而且还得有效，就可以使用解引用符（操作符*）来访问该对象：

```C++
int i = 42;
int *p = &i;

std::cout<< *p ; //对，没错，这里的*就是解引用符。写在表达式里就是解引用符。
```

然后有一个坑就是直接访问指针本身：
```C++
std::cout << p ; //输出的是指针本身！
```
这里就会得到类似0x00000000的16进制数字，这tm的是指针存放的地址啊！！！
还有一个坑就是*到底是指针声明，还是解引用符。。。

对指针解引用会得出指针所指的对象， 因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：

```C++
*p = 0;
std::cout<< *p;
```
那么这又是一个坑啦！
`*p = 0;`是一个表达式语句，`=`赋值算符进行赋值操作。所以`*p`和`0`都是表达式，那么问题来了，`*p`是表达式，为什么能放在等号左边？因为`*p`不是一般的表达式，`*p`的计算结果是一个对象哟！所以也算左值。所以符号`*`也就成了解引用符了。

```C++
//这就是坑！
int *p = &i; //指针定义，指向变量i
*p = 0; //解引用得出指向的对象，给指向的对象赋值。
p = 0;  //给指针本身赋值，赋值0就是使其变为空指针。
```

> 解引用操作仅适用于那些确实指向了某个对象的有效指针。

## 符号的多个含义

像*和&这样的符号，出现在不同的位置代表不同的含义，所以要冷静分析！

## 空指针

空指针(null pointer)不指向任何对象，在试图使用一个指针之前可以首先检查指针是否为空。（还得保证你有初始化指针为空的好习惯，还得有你使得指针无效时顺手赋值为空的好习惯）。
有这些生成空指针的方法：

```C++
int *p1 = nullptr;
int *p2 = 0;
//首先需要#include cstdlib
int *p3 = NULL;
```

这些都是空指针，最直接的方法是使用字面值`nullptr`，这是C++ 11引用的一种方法。`nullptr`空指针字面值，也可以使用字面值0来生成空指针。

过去的程序会用到名为 NULL 的预处理变量(preprocessor variable)，也就是宏(macro)，来给指针赋值，这个变量定义在cstdlib头文件中，而且值就是0。。。

预处理器是在编译过程之前执行的，用的是直接替换。。。所以没有命名空间，直接使用即可，不用加std::。

把变量值赋值给指针是错误的！！！即使变量的值恰好等于0也不行。
他们本来就是不同类型的！！！

```C++
int zero = 0;
int *p = zero; //错误！
```

用字面值0初始化指针那是字面值0隐式转换为指针地址。。。

> 建议：初始化所有的指针。访问未初始化的指针是危险的！先定义对象，再定义指针指向它。如果真的需要后来赋予指针地址，请初始化为空指针，这样就能通过判断指针是否为空来判断指针是否有效。

## 赋值和指针

指针之间是可以拷贝，赋值的哟！
指针也是可以再次指向别的对象。

```C++
int i1 = 42;
int i2 = 36;

int *p1 = &i1;
int *p2 = &i2;
//目前都很正常

p2 = p1; //现在p1,p2都指向i1。

p2 = 0; //这里把p2弄成空指针。

p2 = &i2; //这里使p2指向i2。
```

有时候会搞不清给指针赋值到底是赋值给了指针本身还是指向的对象。。。
要清楚，赋值，是赋值给等号左边的对象的。
指针也是对象啊！！！
你把指针本身写在等号左边，当然会给指针赋值啦。
要想给指针指向的对象赋值，请解引用！

```C++
*p1 = 0; //给p1指向的对象赋值，p1的地址不会变化的。。。
```
## 其他指针操作

将指针本身作为判断条件，也就是指针隐式转化为bool。
只有指针的值是0，条件为false。其他值都是true。

```C++
if (p)
{
    //指针非空条件就成立
    //就会执行这里
}

任何非空指针的条件值都是true。包括无效指针。
所以一定要养成好习惯！初始化时要么指向对象，要么初始化为空指针。
明确有的操作会使指针失效，操作完顺手就将指针赋值为空。
这样就能通过判断是否为空来判断指针是否有效了。

两个指针可以通过相等操作符(==)或者不相等操作符(!=)来比较，是否指向同一个对象。以后迭代操作会用到。
如果两指针存放的地址相同，则他们相等。反之，不相等。
（有个问题，一个指针指向某对象，另一个指针指向对象的下一个地址，也可以指针相等。-----这就是某对象就在某对象下一个位置上。。。）

## void* 指针

`void*` 是一种特殊的类型，可以用来存放任意对象的地址。一个void*指针存放着对象的地址，和其他指针类似。不同的是，不了解改地址指向什么类型的对象。

`void*`指针能做的事情比较有限：和别的指针比较、作为函数输入输出，或者赋值给其他`void*`指针。因为我们并不知道这个对象是什么类型，也就无法确定如何操作这个对象。

`void*`的视角来看内存空间也就仅仅是内存空间，没办法直接访问所指的对象。
需要得出类型，或者有关该对象的其他信息。

比如：malloc返回的就是一个`void*`，使用时需要传参unsigned int n。
使用sizeof(你申请的对象的类型)传参，这就是有关信息。根据这个参数malloc分配适当大小的内存空间，然后返回`void*`，你可以用类型转换，转换为相应类型的指针，从而使用这个指针指向的内存空间。

## 理解复合类型的声明

上面应该说了很多次，复合类型类型只管一个声明符的！！！同一个声明语句定义多个对象时，每个指针或者引用都得加上&或者*符号，不然就是普通类型哟！

> 类型修饰符(&，*那种的)，是声明符的一部分哟！

### 定义多个变量

有个误解，经常会把基本类型和类型修饰符写一起，合法，不过容易产生误导。

```C++
int* p; //说的就是你！
```

写的好像基本类型是`int*`似的。要清楚的认识到，基本数据类型是int！*仅仅修饰了p！
所以，对其他声明符是没有作用的。

```C++
int* p1, p2; //只有p1是指针，p2只是个普通变量
```

所以你要么乖乖的将类型修饰符和变量名写一起。
也就是这样：
```C++
int *p;
```
要么将修饰符和基本类型写在一起，并且每条语句只定义一个变量！强调变量的复合类型，并牢记修饰符的作用范围。
也就是这样：
```C++
int* p1;
int* p2;
```

## 指向指针的指针

多个修饰符可以连写的哟！按照逻辑关系解释即可。
指针本身就是对象，指针本身也拥有地址，所以可以定义指向指针的指针，将指针的地址放入指向指针的指针中。

通过*的个数来区分指针的级别。
`*`表示指针的话。
`**`表示指向指针的指针
`***`表示一个指针，指向`**`类型的对象。（指向指针的指针的指针）。
以此类推。

```C++
int i = 42;
int *p = &i;
int **pp = &p;
int ***ppp = &pp;
//...
```

那么多级的指针也需要多次解引用来一层层剥开原始对象。。。

```C++
std::cout<< ppp; //ppp对象本身
std::cout<< *ppp; //ppp所指对象，也就是pp本身。
std::cout<< **ppp;//ppp所指pp所指的对象，也就是p本身。
std::cout<< ***ppp;//这里得出对象i。
```

## 对指针的引用

引用本身不是对象，所以指针不能只想不存在的“引用对象本身”，不能定义指向引用的指针。
但是指针是对象，引用可以绑定指针本身。

```C++
int i = 42;
int *p;
int *&r = p; //r绑定指针p

r = &i; //操作r，也就是操作p，p指向i。
*r = 0; //r等价p，解引用后得到i，对i赋值。
```

解释下r的定义。
和变量名最近的符号&，表示该名字的本质，是一个引用。符号*紧邻符号&，表示该引用绑定指针。

> 对于复杂的声明语句，从右向左阅读有助于理解。（右左法则？）
