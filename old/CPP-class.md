---
title: C++ 类
date: 2018-07-23 22:17:12
tags:
- C++
---

类的基本思想是数据抽象(data abstraction)和封装(encapsulation)。
数据抽象是一种依赖于接口(interface)和实现(implementation)分离的编程（以及设计）技术。
类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

类想要实现数据抽象和封装，需要首先定义一个抽象数据类型(abstract data type)。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象的思考类型做了什么，而无需了解类型的工作细节。

# 定义抽象数据类型

抽象类型需要定义一些操作以供类的用户使用。
这样才能封装（隐藏）它的数据成员。

类拥有一些成员函数(member function)。

成员函数的声明必须在类的内部，它的定义即可以在类的内部也可以在类的外部。
作为接口组成部分的非成员函数，他们的定义和声明都在类的外部。

> 定义在类内部的函数是隐式的inline函数。

### this

使用点运算符调用成员函数时。
成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。

在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看做this的隐式引用，也就是说，当使用mem时，它隐式的使用this指向的成员，就像我们书写了this->mem一样。

对于我们来说，this形参是隐式定义的。
实际上，任何自定义名为this的参数或者变量的行为都是非法的。
我们可以在成员函数体内部使用this，因此尽管没有必要，但我们还能使用this。

因为this的目的总是指向“这个”对象，所以this是一个常量指针，我们不允许改变this中保存的地址。

### const成员函数

紧随参数列表之后添加const关键字，这里，const的作用是修改隐式this指针的类型。

默认情况下，this的类型是指向类类型非常量版本的常量指针。
例如类C那么this的类型就是C *const。尽管this是隐式的，但它仍然需要遵循初始化规则，意味着（在默认情况下）我们不能把this绑定到一个常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。

我们需要将this声明成指向常量的函数。毕竟，在成员函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。
然而，this是隐式的并且不会出现在参数列表中，所以在哪儿将this声明成指向常量的指针就成为我们必须面对的问题。
C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数(const member function)。

ret_t class::func(...) const
{
    ...
}

因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。

> 常量对象，以及常量对象的引用或指针都只能调用常量成员函数。

### 类作用域和成员函数

类本身就是一个作用域。
类的成员函数的定义嵌套在类的作用域之内。

编译器分两步处理类：
* 首先编译成员的声明
* 然后才轮到成员函数体（如果有的话）。
因此，成员函数体可以随意使用类中的其他成员而无需在意这些成员函数出现的次序。

### 在类的外部定义成员函数

我们在类的外部定义函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致。如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员的名字必须包含它所属的类名

ret_t class::func(...) const
{
    ...
}

函数名使用作用域运算符来说明如下的事实：我们定义了一个名为func的函数，并且该函数被声明在类class的作用域内。
编译器看到这个函数名，就能理解剩余的代码是位于类的作用域内的。
因此，其中能够使用类的数据成员，实际上它隐式的使用了类的数据成员。

### 定义一个返回this对象的函数

class& class::func(...)
{
    ...
    return *this;
}

当我们定义的函数类似于某个内置运算符时（运算符重载），应该令该函数的行为尽量模仿这个运算符。
内置的赋值运算符它的左值运算对象当成左值返回。

我们无需使用隐式this指针访问函数调用者的某个具体成员，而是需要把调用函数的对象当成一个整体来访问。

return *this;

return语句解引用this指针以获得执行该函数的对象，换句话说，这个调用返回引用。

## 定义类相关的非成员函数

类的作者常常需要定义一些辅助函数。
尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。

我们定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来。
如果函数在概念上属于类，但是不定义在类中，则它一般应与类声明（而非定义）在一个头文件内。
在这种方式下，用户使用接口的任何部分都只需要引入一个文件。

> 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。

就是输入输出与该类有关系的一些函数。

## 构造函数

每个类都定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数(constructor)。
构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

构造函数和类名相同。
构造函数没有返回类型；构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。
类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。

构造函数不能被声明成const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。

### 合成的默认构造函数

我们也可以选择不自行定义任何构造函数，然而这种类依然健在，而且也没有报错或者作出未定义的行为。

我们没有为这些对象提供初始值，因此我们知道它们执行了默认初始化过程，这个函数叫做默认构造函数(default constructor)。默认构造函数无须任何实参。

默认构造函数在很多方面都有其特殊性。其中之一是，如果我们的类没有显式的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。

编译器创建的构造函数又被称为合成的默认构造函数(synthesized default constructor)。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：
* 如果存在类内初始值，用它来初始化成员。
* 否则，默认初始化该成员。

### 某些类不能依赖于合成的默认构造函数

合成的默认构造函数只适合非常简单的类。
对于普通的类来说，必须定义它自己的默认构造函数。
原因：
1. 编译器只有发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。（这条规则的依据是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。）
2. 对于某些类来说，合成的默认构造函数可能执行错误的操作。定义在块中的内置类型或复合类型（数组，指针）的对象被默认初始化，则他们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。因此，含有内置类型或复合类型成员的类应该在内的内部初始化这些成员，或者定义一个自己的默认构造函数，否则，用户在创建类的对象时就可能得到未定义的值。
3. 有的时候编译器不能为某些类合成默认的构造函数。例如：如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。还有其他情况也会导致编译器无法生成一个正确的默认构造函数。

> 只有当类没有生命任何构造函数时，编译器才会自动的生成默认构造函数。

> 如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内初始值时，这个类才适合与使用合成的默认构造函数。

### `=default` 的含义

class() = default;

该构造函数不接受任何实参，所以它是一个默认构造函数。
我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。
我们希望这个函数的作用完全等同与之前使用的合成默认构造函数。

C++11中，如果我们需要默认的行为，我们可以通过在参数列表后面写上`=default`来要求编译器生成构造函数。
`=default`既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。
和其他函数一样，如果`=default`出现在类的内部，则默认构造函数是内联的；如果他定义在类的外部，则该成员默认情况下不是内联的。

> 默认构造函数有效，得给内置类型提供类内初始值。如果编译器不支持类内初始值，那个应该使用构造函数初始值列表来初始化类的每一个成员。

### 构造函数初始值列表

class(...) : var(value) {}

新出现的，就是冒号和花括号之间的代码，其中花括号定义了（空的）函数体。
这些部分叫做构造函数初始值列表(constructor initialize list)，它负责为新创建的对象的一个或几个数据成员赋初值。
构造函数初始值是成员名字的一个列表，每个名字后面紧跟括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。

当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。
不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显式的初始化每个内置类型的成员。

> 构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式的初始化每个内置类型的成员。

有一点需要注意的，在上面的两个构造函数中函数体都是空的。这是因为这些构造函数的唯一目的就是为数据成员赋初值，一旦没有其他任务需要执行，函数体也就为空了。

### 在类的外部定义构造函数

class::class(params...)
{
    ...
}

构造函数没有返回类型，所以上述定义从我们指定的函数名字开始。
我们在类的外部定义构造函数的时候，必须指明该构造函数是哪个类的成员。

构造函数初始值列表是可选的。
可以通过构造函数函数体来完成成员的初始化操作。

没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。

## 拷贝、赋值和析构

除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。
对象在几种情况下会被拷贝，如我们初始化变量以及以值的方式传递或返回一个对象等。
当我们使用了赋值运算符时会发生对象的赋值操作。
当对象不再存在时执行销毁的操作，比如一个局部对象会在创建它的块结束时被销毁，当vector对象（或数组）销毁时存储在其中的对象也会被销毁。

如果我们不主动定义这些操作，则编译器将替我们合成它们。
一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。

### 某些类不能依赖于合成的版本

尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。
特别是：当类需要分配类对象之外的资源时，合成的版本常常会失效。

不过值得注意的是，很多需要动态内存的类能（而且应该）使用vector对象或者string对象管理必要的存储空间。使用vector或者string的类能避免分配和释放内存带来的复杂性。

进一步讲，如果类包含vector或者string成员，则其拷贝、赋值和销毁的和合成版本能够正常工作。当我们对含有vector成员的对象执行拷贝或者赋值操作时，vector类会设法拷贝或者赋值成员中的元素。当这样的对象被销毁时，将销毁vector对象，也就是一次销毁vector中的每一个元素。

# 访问控制与封装

到目前为止，我们已经为类定义了接口，但并没有任何机制强制用户使用这些接口。
我们的类还没有封装，也就是说，用户可以直达类对象的内部并且控制它的具体实现细节。
在C++语言中，我们使用访问说明符(access specifiers)加强类的封装性：
* 定义在`public`说明符之后的成员在整个程序内可被访问，public成员定义类的接口。
* 定义在`private`说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。

```C++
class C
{
public:
    //接口部分
private:
    //实现部分
}
```

作为接口的一部分，构造函数和部分成员函数紧跟在public说明符之后；
而数据成员和作为实现部分的函数则跟在private说明符后面。

一个类可以包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符制定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。

### 使用class或structural关键字

class和struct都可以定义类，唯一的区别是：默认访问权限不一样。

类可以咋他的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。
如果我们使用struct关键字，则定义在第一个访问说明符之前的成员时public的；
如果我们使用class关键字，则这些成员是private的。

出于统一编程风格考虑，当我们希望定义的类的所有成员都是public的时，使用struct；
如果希望成员是private的，使用class。

> 使用class和struct定义类唯一的区别就是默认的访问权限。

## 友元

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元(friend)。
如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数生命语句即可。

```C++
class C
{
    friend ret_t func(param);
public:
    ...
}

ret_t func(param);
```

友元声明只能出现在类定义的内部，但是类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。

> 一般来说，最好在类定义开始或结束前的位置集中声明友元。

### 友元的声明

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。
如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。

为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。

> 许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。

一些编译器允许在尚无友元函数的初始声明的情况下调用它。不过即使你的编译器支持这种行为，最好还是提供一个独立的函数声明。这样即使你更换了一个有这种强制要求的编译器，也不必改变代码。

## 封装的益处

封装有两个重要的优点：
* 确保用户代码不会无意间破坏封装对象的状态。
* 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

一旦把数据成员定义成private的，类的作者就可以比较自由的修改数据了。当实现部分改变时，我们只需要检查类的代码本身以确认这次改变有什么影响；换句话说，只要类的接口不变，用户代码就无需改变。如果数据是public的，则所有使用了原来数据成员的代码都可能失效，这时我们必须定位并重写所有依赖于老版本实现的代码，之后才能重新使用该程序。

把数据成员的访问权限设成private还有另外一个好处，这么做能防止由于用户的原因造成的数据被破坏。如果我们发现有程序缺陷破坏了对象的状态，则可以在有限的范围内定位缺陷：因为只有实现部分的代码可能产生这样的错误。因此，将查错限制在有限范围内将能极大的降低维护代码及修正程序错误的难度。

> 尽管当类的定义发生改变时无需更改用户代码，但是使用了该类的源文件必须重新编译。

# 类成员再探

### 定义一个类型成员

类可以自定义某种类型在类中的别名。
由类定义的类型名字和其他成员一样存在访问限制。

```C++
class C
{
public:
    typedef ... ...;
}
```

我们使用了typedef，也可以等价的使用类型别名：

```C++
class C
{
public:
    using ... = ...;
}
```

其次，用来定义类型的成员必须先定义后使用。类型成员通常出现在类开始的地方。

### 令成员函数内联

我们可以在类的内部把inline作为声明的一部分显式的声明成员函数。
也能在类的外部用inline关键字修饰函数的定义。

```C++
inline ret_t class::mem(...)
{
    ...
}
```

虽然我们无需在声明和定义的地方同时说明inline，但这么做其实是合法的。
不过，最好只在类外部定义的地方说明inline，这样可以使类更容易理解。

> inline成员函数应该与相应的类定义在同一个头文件中。

### 重载成员函数

成员函数可以被重载，只要函数之间在参数数量或类型上有所区别就行。
成员函数的匹配过程同样与非成员函数非常类似。

### 可变数据成员

我们希望能修改类中的某个数据成员，即使是在一个const成员函数内。
可以通过在变量的声明中加入`mutable`关键字。

一个可变数据成员(mutable data member)永远不会是const，即使它是const对象的成员。
因此，一个const成员函数可以改变一个可变成员的值。

```C++
class C
{
    mutable T var;
}
```

### 类数据成员的初始值

```C++
class C
{
    T var{...};
}
```

类内初始值必须使用=的初始化形式或者花括号括起来的直接初始化形式。

> 当我们提供一个类内初始值时，必须以符号=或者花括号表示。

# 返回*this的成员函数

```C++
class C
{
    C& func(...)
    {
        return *this;
    }
}
```

返回的就是调用对象的引用。
返回引用的函数时左值的，意味着这些函数返回的是对象本身而非对象的副本。
我们就能把这些操作连接起来。

```C++
obj.func().func().func();
```

加入当我们定义的返回类型不是引用，则返回值将是*this的副本，因此只能改变副本。

### 从const成员函数返回*this

那么const成员函数返回的*this不能再修改。

> 一个const成员函数如果以引用的形式返回*this，那个它的返回值将是常量引用。

### 基于const的重载

通过区分成员函数是否是const的，我们可以对其进行重载，其原因与我们之前根据指针参数是否指向const而重载函数的原因差不多。
具体说来，因为非常量版本的函数对于常量对象是不可用的，所以我们只能再一个常量对象上吊用const成员函数。另一方面，虽然可以在非常量对象上吊用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。

```C++
class C
{
    C& func(...)
    {
    }
    const C &func(...) const
    {
    }
}
```

当我们在某个对象上吊用func时，该对象是否是const决定了应该吊用display的哪个版本。

> 建议：公共代码使用私有功能函数
> 避免重复的代码，用来完成实际工作

# 类类型

每个类定义了唯一的类型。
对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。

> 即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类来说，它的成员和其他任何类（或者任何其他作用域）的成员都不是一回事儿。

我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class或struct后面。

```C++
classname obj; //这个类类型的对象
class classname obj; //一条等价的声明
```

这两种使用类类型的方式是等价的，其中第二种方式从C语言继承而来，并且在C++语言中也是合法的。

### 类的声明

就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它。

```C++
class classname; //类的声明
```

这种声明有时被称作前向声明(forward declaration)，他向程序中引入了名字并且指明该名字是一种类类型。
对于该类型来说，在它声明之后定义之前是一个不完全类型(incomplete type)也就是说，此时我们已知该类型是一个类类型，但是不清楚它到底包含哪些成员。

不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。

对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。否则，编译器就无法了解这样的对象需要多少存储空间。类似的，类也必须首先被定义，然后才能用引用或者指针访问其成员。毕竟，如果类尚未定义，编译器也就不清楚该类到底有哪些成员。

例外：直到类被定义之后数据成员才能被声明成这种类类型。换句话说，我们必须首先完成类的定义，然后编译器才能直到存储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针：

```C++
class C
{
    otherclass obj;
    C *ptr;
}
```

# 友元再探

类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。
友元函数能定义在类的内部，这样的函数是隐式内联的。

### 类之间的友元关系

```C++
class C
{
    friend class friend_class;
}
```

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

必须注意的一点是，友元不存在传递性。

> 每个类负责控制自己的友元类或友元函数。

### 令成员函数作为友元

除了令整个类作为友元之外，可以只为某个成员函数提供访问权限。
当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类。

```C++
class C
{
    friend class::mem(...);
}
```

要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。

### 函数重载和友元

尽管重载函数的名字相同，但他们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。

### 友元声明和作用域

类和非成员函数的声明不是必须在他们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式的假定该名字在当前作用域中时可见的。然而，友元本身不一定真的声明在当前作用域中。

甚至就算再类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的。

```C++
struct X
{
    friend void f() {/*友元函数可以定义在类的内部*/}
    X() { f(); }
    void g();
    void h();
};

void X::g() { return f(); } //错误：f还没有被声明
void f(); //声明那个定义在X中的函数
void X::h() { return f(); } //正确：现在f的声明在作用域中了
```

> 请注意，有的编译器并不强制执行上述关于友元的限定规则。

# 类的作用域

每个类都会定义它自己的作用域。
在类的作用域之外，普通的数据和函数成员只能由对象、引用或指针使用成员运算符来访问。
对于类类型成员则使用作用域运算符访问。
不论哪种情况，跟在运算符之后的名字都必须是对应类的成员。

```C++
classname::type var = value; //使用classname定义的type类型
classname obj(...);
classname *p = &obj;
auto c = obj.mem(); //访问obj对象的mem成员
c = p->mem(); //访问p所指对象的mem成员
```

### 作用域和定义在类外部的成员

一个类就是一个作用域的事实能很好的解释为什么当我们在类的外部定义成员函数时必须同时提供类名和函数名。在类的外部，成员的名字被隐藏起来了。

一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无需再次授权了。

另一方面，函数的返回类型通常出现在函数名之前，
因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外，
这是，返回类型必须指明它是那个类的成员。

```C++
classname::type
classname::mem(...)
{
    ...
}
```

## 名字查找与类的作用域

目前为止，名字查找(name lookup)（寻找与所用名字最匹配的声明的过程）的过程比较直截了当：
* 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。
* 如果没找到，继续查找外层作用域。
* 如果最终没有找到匹配的声明，则程序报错。

对于定义在类内部的成员来说，解析其中名字的方式与上述的查找规则有所区别，不过在当前的这个例子中体现的不太明显。
类的定义分两步处理：
* 首先，编译成员的声明。
* 直到类全部可见后才编译函数体

> 编译器处理完类中的全部声明后才会处理成员函数的定义。

按照这两种两阶段的方式处理类可以简化代码的组织方式。因为成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字。相反，如果函数的定义和成员的声明被同时处理，那么我们将不得不在成员函数中只使用那些已经出现的名字。

### 用于类成员声明的名字查找

这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的而名字，则编译器将会定义该类的作用域中继续查找。

例如：
```C++
typedef double Money;
string bal;
class Account
{
public:
    Money balance() {return bal;}
private:
    Money bal;
    //...
}
```

当编译器看到balance函数的声明语句时，它将在Account类的范围内查找对Money的声明。
编译器只考虑Account中在使用Money前出现的声明，因为没找到匹配的成员，所以编译器会接着到Account的外层作用域中查找。
在这个例子中，编译器会找到Money的typedef语句，该类型被用作balance函数的返回类型以及数据成员bal的类型。
另一方面，balance函数体在整个类可见后才被处理，因此，该函数的return语句返回名为bal的成员，而非外层作用域的string对象。

### 类型名要特殊处理

一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字：

```C++
typedef double Money;
class Account
{
public:
    Money balance() { return bal; } //使用外层作用域的Money
private:
    typedef double Money; //错误：不能重新定义Money
    Money bal;
}
```

需要特别注意的是，即使Account中定义的Money类型域外层作用域一致，上述代码仍然是错误的。

尽管重新定义类型名字是一种错误的行为，但是编译器并不为此负责。一些编译器仍将顺利通过这样的代码，而忽略代码有错的事实。

> 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

### 成员定义中的普通块作用域的名字查找

成员函数中使用的名字按照如下方式解析：

* 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的名字才被考虑。
* 如果，在成员函数内也没有找到，则在类内继续查找，这是类的所有成员都可以被考虑。
* 如果类内也没找到改名子的声明，在成员函数定义之前的作用域内继续查找。

一般来说，不建议使用其他成员的名字作为某个成员函数的参数。
不过为了更好的解释名字的解析过程，我们不妨在dummy_fcn函数中暂时违反下这个约定：

```C++
//注意：这段代码仅为了说明而用，不是一段很好的代码
//通常情况下不建议为参数和成员使用同样的名字
int height; //定义了一个名字，稍后将在Screen中使用
class Screen
{
public:
    typedef std::string::size_type pos;
    void dummy_fcn(pos height)
    {
        cursor = width * height; //那个height？是那个参数
    }
private:
    pos cursor = 0;
    pos height = 0, width = 0;
};
```

当编译器处理dummy_fcn中的乘法表达式时，它首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此dummy_fcn函数体内用到的名字height指的是参数声明。

在此例中，height参数隐藏了同名的成员。如果想绕开上面的查找规则，应该将代码变为：

```C++
//不建议的写法：成员函数中的名字不应该隐藏同名的成员
void Screen::dummy_fcn(pos height)
{
    cursor = width * this->height; //成员height
    //另外一种表示该成员的方式
    cursor = width * Screen::height; //成员height
}
```

> 尽管类的成员被隐藏了，但我们仍然可以通过加上类的名字或显式的使用this指针来强制访问成员。

其实最好的确保我们使用height成员的方法是给参数起个其他名字：

```C++
//建议的写法：不要把成员名字作为参数或其他局部变量使用
void Screen::dummy_fcn(pos ht)
{
    cursor = width * height; //成员height
}
```

### 类作用域之后，在外围的作用域中查找

如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。

在我们的例子中，名字height定义在外层作用域中，且位于Screen的定义之前。
然而，外层作用域中的对象被名为height的成员隐藏掉了。
因此，如果我们需要的是外层作用域中的名字，可以显式的通过作用域运算符来进行请求。

```C++
void Screen::dummy_fcn(pos height)
{
    cursor = width * ::height; //哪个height?是那个全局的
}
```

> 尽管外层的对象被隐藏掉了，但我们仍然可以用作用域运算符访问它。

### 在文件中名字的出现处对其进行解析

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。

```C++
int height; //定义了一个名字，稍后将在Screen中使用
class Screen
{
public:
    typedef std::string::size_type pos;
    void setHeight(pos);
    pos height = 0; //隐藏了外层作用域中的height
};
Screen::pos verify(Screen::pos);
Void Screen::setHeight(pos var)
{
    //var:参数
    //height:类的成员
    //verify:全局函数
    height = verify(var);
}
```

请注意，全局函数verify的声明在Screen类的定义之前时不可见的。然而，名字查找的第三步包括了成员函数出现之前的全局作用域。
在此例中，verify的声明位于setHeight的定义之前，因此可以被正常使用。

# 构造函数再探

## 构造函数初始值列表

当我们定义变量时习惯于立即对其进行初始化，而非先定义、再赋值。

```C++
string foo = "hello, world!"; //定义并初始化

string bar; //默认初始化成空string对象
bar = "hello, world!"; //为bar赋一个新值
```

就对象的数据成员而言，初始化和赋值也有类似的区别。
如果没有再构造函数的初始值列表中显式的初始化成员，则该成员将在构造函数体之前执行默认初始化。

```C++
//虽然合法但比较草率：没有使用构造函数初始值
classname::classname(...)
{
    mem = value;
    ...
}
```

这个版本对数据成员执行了赋值操作
和初始化的区别的影响完全依赖于数据成员的类型。

### 构造函数的初始值有时必不可少

有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者是引用的话，必须将其初始化。
类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

```C++
class ConstRef
{
public:
    ConstRef(int ii);
private:
    int i;
    const int ci;
    int &ri;
};
```

和其他常量对象或者引用一样，成员ci和ri都必须被初始化。
因此，如果我们没有为他们提供构造函数初始值列表的话将引发错误。

```C++
//错误：ci和ri必须被初始化
ConstRef::ConstRef(int ii)
{
    //赋值
    i = ii; //正确
    ci = ii; //错误：不能给const赋值
    ri = i; //错误：ri没被初始化
}
```

随着构造函数体一开始执行，初始化就完成了。我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此该构造函数的正确形式应该是：

```C++
//正确：显式的初始化引用和const成员
ConstRef::ConstRef(int ii) : i(ii), ci(ii), ri(i) {}
```

> 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。

> 建议：使用构造函数初始值
> 在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。
> 除了效率问题外更严重的是，一些数据成员必须被初始化。建议读者养成使用构造函数初始值的习惯，这样能避免某些意想不到的编译错误，特别是遇到有的类含有需要构造函数初始值的成员时。

### 成员初始化的顺序

显然，在构造函数初始值中每个成员只能出现一次。否则，给同一个成员赋两个不同的初始值有什么意义呢？

不过让人稍感意外的是，构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。

成员初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。

一般来说，初始化的顺序没什么特别要求。不过如果一个成员是用另一个成员类初始化的，那么这两个成员的初始化顺序就很关键了。

举个例子，考虑下面这个类：

```C++
class X
{
    int i;
    int j;
public:
    //未定义的：i在j前被初始化
    X(int val) : j(val), i(j) {}
};
```

在此例中，从构造函数初始值的形式上来看仿佛是先用val初始化了j，然后再用j初始化了i。实际上，i先被初始化，因此这个初始值的效果是试图使用未定义的值j初始化i！

有的编译器具备一项比较友好的功能，即当构造函数初始值列表中的数据成员顺序与这些成员声明的顺序不符时会产生一条警告信息。

> 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。

如果可能的话，最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是我们可以不必考虑成员的初始化顺序。例如，X的构造函数如果写成如下的形式效果会更好：

```C++
X(int val) : i(val), j(val) {}
```

在这个版本中，i和j初始化的顺序就没什么影响了。

### 默认实参和构造函数

```C++
class classname
{
public:
    classname(T arg = value, ...)
    { }
}
```

我们不提供实参也能调用拥有默认实参的构造函数。
这个函数也就提供了默认构造函数。

> 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

## 委托构造函数

C++11新标准扩展了构造函数初始值的功能。
我们可以定义委托构造函数(delegating constructor)。一个委托构造函数使用他所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。

和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。
在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。

```C++
class classname
{
public:
    classname::cons(...) {}
    
    classname::cons1() : cons(...)
    { }
}
```

受委托的构造函数执行完后，接着执行委托方构造函数体的内容。

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。
先执行受委托的构造函数的函数体，然后才会执行委托者的函数体。

## 默认构造函数的作用

当对象被默认初始化或值初始化时会自动执行默认构造函数。
默认初始化在以下情况下发生：
* 当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时。
* 当一个类本身含有类类型的成员且使用合成的默认构造函数时。
* 当类类型的成员没有在构造函数初始值列表中显式的初始化时。

值初始化在以下情况下发生：
* 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。
* 当我们不使用初始值定义一个局部静态变量时。
* 当我们通过书写形如T()的表达式显式的请求值初始化时，其中T是类型名。

类必须包含一个默认构造函数以便在上述情况下使用，其中的大多数情况非常容易判断。

不那么明显的一种情况是类的某些数据成员缺少默认构造函数：

```C++
class classname
{
public:
    NoDefault(const std::string);
    //还有其他成员，但是没有其他构造函数了
};
struct A //默认情况下my_mem是public的
{
    NoDefault my_mem；
}；

A a; //错误：不能为A合成构造函数
struct B
{
    B() {} //错误：b_member没有初始值
    NoDefault b_member;
}
```

> 在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。

### 使用默认构造函数

下面的obj的声明可以正常编译通过。

```C++
classname obj(); //正确：定义了一个函数而非对象
obj.mem(); //错误：obj是一个函数
```

我们想声明一个默认初始化的对象，obj的实际含义确实一个不接受任何参数的函数并且其返回值是classname类型的对象。

如果想定义一个使用默认构造函数进行初始化的对象，正确的方法是去掉对象名之后的空的括号对：

```C++
//正确：obj是个默认初始化的对象
classname obj;
```

> 对于C++的新手程序员来说有一种常犯的错误，它们试图以如下的形式声明一个用默认构造函数初始化的对象：
> classname obj(); //错误：声明了一个函数而非对象
> classname obj2; //正确：obj2是一个对象

## 隐式的类类型转换

我们也能为类定义隐式转换规则。
如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，又是我们把这种构造函数成为转换构造函数(converting constructor)。

> 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。

使用classname的地方用其他类型，如果定义了这个类型的转换构造函数，那么可以用这个函数发生隐式转换。
编译器会自动创建一个临时对象来代替原来的其他类型的值参与运算。

### 只允许一步类类型转换

编译器只会自动的执行一步类型转换。
如果隐式的使用两种转换规则，那么就是错误的。

### 类类型转换不总是有效

转换得到的是临时量，一旦这个表达式完成，我们就不能访问它了。

### 抑制构造函数定义的隐式转换

在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为`explicit`加以阻止：

```C++
class classname
{
public:
    explicit classname(T arg);
}
```

这样就不能用相应的隐式转换。

关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用与隐式转换，所有无需将这些构造函数制定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应该重复。

```C++
explicit classname::classname(T arg)
{

}
```

### explicit构造函数只能用于直接初始化

发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=）。此时，我们只能使用直接初始化而不能使用explicit构造函数。

```C++
classname obj1(arg); //正确：直接初始化
classname obj2 = arg; //错误：不能将explicit构造函数用于拷贝形式的初始化过程
```

> 当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。

### 为转换显式的使用构造函数

尽管编译器不会讲explicit的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式的执行强制进行转换。

```C++
classname(value) //显式构造一个对象

static_cast<classname>(value) //正确：static_cast可以使用explicit的构造函数
```

## 聚合类

聚合类(aggregate class)使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：
* 所有成员都是public的。
* 没有定义任何构造函数
* 没有类内初始值
* 没有基类，也没有virtual函数。

例如：

```C++
struct Data
{
    int x;
    int y;
}
```

我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员。

```C++
//d.x = 0; d.y = 0
Data d = { 0, 0 };
```

初始化顺序必须与声明顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推。

与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的而成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。

值得注意的是，显式的初始化类的对象的成员存在三个明显的缺点：
* 要求类的所有成员都是public的。
* 将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。
* 添加或删除一个成员之后，所有的初始化语句都需要更新。

## 字面值常量类

某些类也可以是字面值类型。
字面值类型的类可能含有constexpr函数成员。这样的成员必须符合constexpr函数的所有要求，他们是隐式const的。

数据成员都是字面值类型的聚合类是字面值常量类。
如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：
* 数据成员必须都是字面值类型。
* 类必须至少含有一个constexpr函数。
* 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr函数。
* 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

### constexpr构造函数

尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。

constexpr构造函数可以声明成=default的形式或者是删除函数的形式。
否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句。）综合这两点可知，constexpr构造函数体一般来说应该是空的。我们通过前置关键字constexpr就可以声明一个constexpr构造函数了：

```C++
class Debug
{
public:
    constexpr Debug(bool b = true) : hw(b), io(b), other(b) {}
    constexpr Debug(bool h, bool i, bool o):
        hw(h), io(i), other(o) {}
    constexpr bool any() { return hw || io || other; }
    void set_io(bool b) {io = b;}
    void set_hw(bool b) {hw = b;}
    void set_other(bool b) {hw = b;}
private:
    bool hw; //硬件错误，而非IO错误
    bool io; //IO错误
    bool other; //其他错误
};
```

constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。

cosntexpr构造函数用于生成constexpr对象以及constexpr函数的而参数或返回类型。

```C++
constexpr Debug io_sub(false, true, false); //调试IO
if (io_sub.any()) //等价于if(true)
    cerr << "print appropriate error message" << endl;
constexpr Debug prod(false); //无调试
if (prod.any()) //等价于if(false)
    cerr << "print an error message" << endl;
```

# 类的静态成员

有时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。

### 声明静态成员

我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型等。

```C++
class classname
{
public:
    static T var;
    static T func(...);
}
```

类的静态成员存在于任何对象之外，对象中不包含任何与静态成员有关的数据。

静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。这一限制即适用于this的显式使用，也对调用非静态成员的隐式使用有效。

### 使用类的静态成员

我们使用作用域运算符直接访问静态成员

```C++
classname::mem(); //使用作用域运算符访问静态成员
```

虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或指针来访问静态成员。
成员函数不用通过作用域运算符就能直接使用静态成员。

### 定义静态成员

我们即可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句。

> 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。

因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。
和其他对象一样，一个静态成员只能被定义一次。

静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。

我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字。

```C++
T classname::mem = value;
```

从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。也可以访问类的私有成员。

> 要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。

### 静态成员的类内初始化

通常情况下，类的静态成员不应该在类的内部初始化
然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。
初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合与常量表达式的地方。

如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了。

> 即使一个常量静态数据成员再类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。

### 静态成员能用于某些场景，而普通成员不能

静态成员可以是不完全类型。

特别的，静态数据成员的类型可以就是它所属的类类型。
而非静态数据成员则受到限制，只能声明成它所属类的指针或引用。

```C++
class C
{
    static C mem1; //正确：静态成员可以是不完全类型
    C *mem2; //正确：指针成员可以是不完全类型
    C mem3; //错误：数据成员必须是完全类型
};
```

静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参。
非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。

