---
title: C++ const 限定符
date: 2018-07-14 15:55:23
tags:
- C++
---

使用const限定符，定义一个常量，使得其值不能再改变。
常量必须初始化，因为不允许改变它的值。。。所以就要在创建时赋予初始值。

使用关键字const加以限定：
```C++
const int ic = 42;
```

# 初始化和const

常量只是不能修改它的值啦。它还是能参与大部分的运算的。
初始化并没有改变常量的值，是赋予！！！不然咋用？
初始化和赋值时两个概念！！！

# 默认情况下，const对象仅在文件内有效

默认情况下，const只在文件内有效。
当多个文件中出现了同名的const变量时，他们互相独立。

如果想要多个文件内共享const对象。我们可以只在一个文件中定义它，然后在其他多个文件中声明并使用它。

对于const对象不管声明还是定义都添加extern关键字，然后只对一个初始化使其成为定义就行。
```C++
//定义
extern const int c = fcn(); //获取一个迷之常量

//其他文件中
extern const int c;
```

声明写进头文件是个不错的选择。

> 如果想在多个文件中共享const对象，必须在变量的定义之前添加extern关键字。

# const 的引用

可以吧引用绑定在const对象上，就像绑定在其他对象上一样，叫对常量的引用(reference to const)。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```C++
const int ci = 42;
const int &cr = ci; //正确

r1 = 0; //错误，r1是对常量的引用
int &r2 = ci; //错误：普通引用不能绑定常量对象。
```

## 初始化对const的引用

前面提到：引用的类型必须与其所引用的对象的类型一致，但是有两个例外。
1. 初始化对常量的引用时允许用任意表达式作为初始值，只要该表达式能够转换成引用的类型即可。
2. 允许为一个对常量的引用绑定非常量的对象、字面值，甚至是一个一般表达式。

```C++
int i = 42;
const int &r1 = i; //允许绑定到变量上

const int &r2 = 42; //正确
const int &r3 = r1 * 2; //正确

int &r4 = r1 * 2; //错误，r4是一个普通引用
```

对常量的引用在绑定到另外一种类型的对象上时，或者绑定到字面值，表达式时，由编译器创建一个临时量(temporary)。如果是普通引用，就违背了引用的定义，对该引用赋值时，只能修改临时量，你也别指望编译器能根据表达式解方程，(`int &r = x * x;`，你要修改r的话，x就可以取两个值哟！喂！醒醒，这跟量子计算也没关系。)，所以只有对常量的引用能绑定其他类型的对象以及绑定表达式。

## 对const的引用可能引用一个非const的对象

对常量的引用仅对可参与的操作做出了限定，而且限定的是该引用本身！对于引用的对象本身是否是常量未做限定。而且普通引用无法绑定常量是因为普通引用会提供修改常量的方式，对常量的引用对引用本身加以限定，使其能够绑定常量。而对常量的引用完全有理由绑定变量，变量又不是不能读取。。。（傲娇）。。。而且这么做还提供了新的思路：我们可以自己操作变量，然后传递一个对常量的引用给别人，这样就能达到“我能改值，你就是不行”的效果。

```C++
int i = 42;
const int &r = i;
i = 1024; //没问题
r = 2048; //错误，该引用是对常量的引用。
```

对常量的引用绑定变量是可以的。然而，不允许通过该引用修改被引用对象的值，但是，允许通过其他途径修改，也可以直接给被引用对象赋值，也可以通过绑定被引用对象的其他普通引用来修改。

# 指针和 const

类似的，有指向常量的指针(pointer to const)。不能用于改变其所指对象的值。想要存放常量的地址，只能使用此类指针。（注意是此类！！！）

```C++
const double pi = 3.14;

double *ptr = &pi; //错误，ptr是普通指针
const double *cptr = &pi; //正确！
*cptr = 42; //错误，不能给*cptr赋值。
```

前面提到：“指针的类型必须与其所指对象的类型一致，但是有两个例外。
例外一：允许令一个指向常量的指针指向一个非常量对象。
```C++
double dval = 3.14;
const double *cptr = dval;
```

指向常量的指针仅仅要求不能通过该指针改变对象的值。

# const指针

因为指针是对象，所以就可以让指针本身定位常量。
那就是常量指针(const pointer)！
常量指针必须初始化，一旦初始化，它的值（也就是存放的地址）就不能改变了。
把`*`放在关键字`const`之用以说明指针是一个常量，这么书写意味着，不变的指针本身！

```C++
int i = 42;
int *const cp = &i; //cp将一直指向i
const double pi = 3.14;
const double *const pip = &pi; //pip是一个指向常量的常量指针
```

常量指针指向非常量的话，照样解引用赋值。

# 顶层const

前面说的，指针本身是一个对象，它可以指向另一个对象。
指针本身是不是常量以及指针所指的是不是常量就是两个相互独立的问题。
用名词顶层const(top-level const)表示指针本身是个常量。
名词底层const(low-level const)表示指针所指的对象是一个常量。

更一般的，顶层const可以表示任意的对象是常量，这对任何数据类型都适用。
底层const则与指针和引用等复合类型有关。
特殊的是，指针既可以是顶层const也可以是底层const。

```C++
int i = 0;
int *const p1 = &i; //不能改变p1的值，这是顶层const
const int ci = 42;  //不能改变ci的值，这是顶层const
const int  *p2 = &ci; //允许改变p2的值，这是底层const
const int *const p3 = p2; //右边的const是顶层const，左边的是底层const
const int &r = ci; //用于声明引用的const都是底层const
```

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。
顶层const不受什么影响。

```C++
i = ci; //正确：拷贝ci的值，ci是一个顶层const，对此操作无影响
p2 = p3; //正确：p2和p3指向的对象的类型相同，p3顶层const的部分不影响
```

底层const的限制不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。

```C++
int *p = p3; //错误：p3包含底层const的定义，而p没有
p2 = p3; //正确：p2和p3都是底层const
p2 = &i; //正确：int*能转换成const int*
int &r = ci; //错误：普通的int&不能绑定到int常量上
const int &r2 = i; //正确：const int&可以绑定到一个普通的int上
```

不能用p3初始化p，因为p指向的是一个普通（非常量）整数。
p3的值可以赋给p2，因为这两个指针都是底层const，p3的顶层const没影响。

# constexpr 和常量表达式

常量表达式(const expression)是指值不会改变并且在编译过程就能得到计算结果的表达式。
显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定。

```C++
const int c1 = 20; //是常量表达式
const int c2 = c1 + 1; //是常量表达式
int i = 42; //不是常量表达式
const int j = get_size();  //不是常量表达式
```

## constexpr 变量

在一个复杂的系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。

C++11新标准，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。
声明为constexpr的变量一定是一个常量，而且必须用常量表达式来初始化。

```C++
constexpr int i1 = 42; //是常量表达式
constexpr int i2 = i1 + 1; //是常量表达式
constexpr int i3 = size(); //只有当size是一个constexpr函数时才是常量表达式
```

尽管普通函数不是常量表达式，但是新标准允许定义一种特殊的constexpr函数，能够成为常量表达式。

> 一般来说，如果你认定变量是一个常量表达式，那就把它声明为constexpr类型。（我觉得有问题）

> 如果你要一个常量表达式，那就声明一个constexpr变量然后交给编译器去验证。

## 字面值类型

尽管指针和引用都能定义成constexpr，但是他们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是储存于某个固定地址中的对象。

函数体内定义的变量一般来说并非储存在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址不变，能用来初始化constexpr指针。
还有就是局部静态变量，有效范围超出函数本身的变量，也拥有固定地址，constexpr引用和指针能够绑定或者指向。

## 指针和constexpr

如果用constexpr限定指针，限定符constexpr仅对指针有效，与指针所指的对象无关。

