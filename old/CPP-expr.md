---
title: C++ 表达式
date: 2018-07-20 20:07:44
tags:
- C++
---

表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result)。字面值和变量是最简单的表达式(expression)，其结果就是字面值和变量的值。把一个运算符(operator)和一个或多个运算对象组合起来可以生成较复杂的表达式。

# 基础

运算符有优先级(precedence)、结合律(associativity)以及运算对象的求值顺序(order of evaluation)。

有类型转换。

用户可以定义重载运算符(overloaded operator)。

左值(lvalue)和右值(rvalue)

* 赋值运算符需要一个非常量左值作为其左侧运算对象，得到的结果也仍然是一个左值。
* 取地址符作用于一个左值运算对象，返回一个指向改运算对象的指针，这个指针是一个右值。
* 内置解引用运算符，下标运算福，迭代器解引用，标准容器的下标运算符，的求值结果都是左值。
* 内置类型和迭代器的递增递减运算符，作用于左值运算对象，其前置版本所得的结果也是左值。

表达式求值结果是左值，decltype的结果是一个引用类型。然而取地址返回的是右值哟！

## 优先级和结合律

复合表达式(compound expression)是指含有两个或多个运算符的表达式。

由表达式组合方式，运算符的优先级和结合律，还有求值顺序控制表达式的求值。

## 括号无视优先级和结合律

括号无视普通的组合规则，表达式中括号括起来的部分被当做一个单元来求值，然后其他部分按照优先级组合。

## 求值顺序

大多数情况下，求值顺序是不确定的。

例如：`int i = f1() * f2();`f1和f2谁先谁后或者一起等求值顺序是不清楚的。

对于没有指定执行顺序的运算符来说，如果有表达式指向并修改了同一个对象，这就会产生未定义的行为，可能引发错误。
这种表达式的行为不可预知！！！

有4种运算符明确规定了运算对象的求值顺序。
1. 逻辑与(&&)，规定先求左侧运算对象的值，只有当左侧对象的值为真时才继续求右侧运算对象的值。
2. 逻辑或(||)
3. 条件运算符(?:)
4. 逗号运算符(,)

> 书写复合表达式的经验准则
> 1.拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
> 2. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。
> 规则二的例外：递增递减运算符不在表达式求值过程中修改变量的值，而且这种写法很常见，不会造成什么问题。

# 算术运算符

|运算符|功能|用法|
|:---:|:---:|:---:|
|+|一元正号| +expr |
|-|一元负号| -expr |

|运算符|功能|用法|
|:---:|:---:|:---:|
|*|乘法|expr * expr|
|/|除法|expr / expr|
|%|求余|expr % expr|

|运算符|功能|用法|
|:---:|:---:|:---:|
|+|加法|expr + expr|
|-|减法|expr - expr|

按照运算符的优先级分组。
这些运算符都满足左结合律，从左向右组合。

一元负号作用于运算对象取负后，返回其（提升后的）副本。

```C++
bool b = true;
bool b2 = -b; //b2是true！
```

b是真，提升为整数值1，求负后的结果是-1,-1不等于0，所以转换为布尔值是true，所以b2是真！

> 溢出和其他算术运算异常
> 算符表达式可能产生未定义的结果。一方面是数学性质本身，例如除数是0的情况；另外一部分源于计算机的特点，例如溢出，当计算的结果超出该类型所能表示的范围就会溢出。
> 环绕(wrapped around)运算结果溢出，将符号位改成了1，于是结果变成一个负值。

整数相除的结果还是整数，对于除法，如果商有小数部分，直接丢弃。（向零取整）

求余运算符，计算两整数相除所得的余数，参数求余运算的运算对象必须是整数类型。（除尽了当然返回0啊！）

# 逻辑和关系运算符

|结合律|运算符|功能|用法|
|:--:|:---:|:--:|:--:|
|右|!|逻辑非| !expr |

|结合律|运算符|功能|用法|
|:--:|:---:|:--:|:--:|
|左|<|小于| expr < expr |
|左|<=|小于等于| expr <= expr |
|左|>|大于| expr > expr |
|左|>=|大于等于| expr >= expr |

|结合律|运算符|功能|用法|
|:--:|:---:|:--:|:--:|
|左|==|相等| expr == expr |
|左|!=|不相等| expr != expr |

|结合律|运算符|功能|用法|
|:--:|:---:|:--:|:--:|
|左|&&|逻辑与| expr && expr |

|结合律|运算符|功能|用法|
|:--:|:---:|:--:|:--:|
|左|`||`|逻辑或|`expr || expr`|

逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧对象的值，当且仅当左侧运算对象的值无法确定表达式的结果时才会计算右侧运算对象的值。这种策略成为短路求值(short-circuit evaluation)。

* 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。
* 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。

短路求值的特性很有用，比如assert宏的实现。

关系运算符的求值结果是布尔值，所以讲几个关系运算符连写在一起会产生意想不到的结果
比如这样就是错的：
```C++
if(i < j < k)
//竟然拿i < j的布尔值结果与k比较
```
牢记，编程不是数学，数学上的简写不一定在编程上有效。
比如易语言的三联判断表达式，这就是另外加的语法，不普遍，然后和关系判断运算符组合就会更爽。

正确写法是：
```C++
if(i < j && j < k)
```

> 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。

# 赋值运算符

赋值运算符的左侧运算对象必须是一个可修改的左值。
```C++
42 = i; //这么皮就是错误的
```

赋值运算的结果是它的左侧运算对象，并且是一个左值，结果的类型就是左侧运算对象的类型。
如果类型不同，则右侧运算对象将转换成左侧运算对象的类型。（转换不了就报错么。）

C++11允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。

无论左侧运算对象的类型是什么，初始值列表都可以为空。
此时，编译器创建一个值初始化的临时量并将其赋给左侧运算对象。

## 赋值满足右结合律

所以多个赋值语句，从右向左组合。
求值以后，返回左侧对象，由此传递值。

多重赋值的话，每个对象，它的类型要么相同，或者可由右侧对象的类型转换到左侧对象。（不行就报错么）

## 赋值运算优先级较低

这样赋值就不用担心作用范围的问题了。

## 不要混淆相等运算符和赋值运算符

赋值运算作为条件，是可以转换为布尔类型的。。。然后就带来了意想不到的结果
```C++
if (i = j)
```
这样的话，如果j不为0，条件就为真！而且大多数情况下条件都是真。。。
然而程序员的初衷很可能是判断是否相等。。。
```C++
if (i ==j)
```
这种错误比较难发现。。。

## 复合赋值运算符

我们经常需要对对象施以某种运算，然后把计算的结果再赋给该对象。
比如：`i = i + 1`用复合赋值就能缩写为`i += 1`。（更近一步，只加一而且还是整数的话，就用`++i`么）
符合操作不仅对加法来说很常见，还有很多别的：
+= -=  *= /= %= //算术运算符
<<= >>= &= ^= |= //位运算符

# 递增和递减运算符

递增运算符(++)和递减运算符(--)为对象的加1和减1操作提供了简洁的书写形式。

递增和递减运算符有两种形式：前置版本和后置版本。
前置版本：先将对象值递增或者递减，改变后的值参与运算。
后置版本：先以对象原来的值参与运算，然后再递增或者递减对象的值。

> 建议：除非必须，否则不用递增或者递减运算符的后置版本
> 后置版本需要将原始值储存下来以便返回那个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。

## 在一条语句中混用解引用和递增运算符

`*pbeg++`等价于`*(pbeg++)`，pbeg参与运算，然后被解引用，最后递增。
比较下优先级就行。

## 运算对象可按任意顺序求值

```C++
*beg = toupper(*beg++); //未定义的赋值
```
赋值运算符两边运算对象都用到了beg，而且右侧的运算对象还改变了beg的值！所以该语句是未定义的。

# 成员访问运算符

点运算符(.)和箭头运算符(->)都可用于访问成员。
点运算符用于获取类对象的一个成员。
箭头运算符用于获取类对象指针的成员，和点运算符有关，是一种简写，表达式`ptr->mem`等价于`(*ptr).mem`。

因为优先级的问题，如果没加括号，含义会改变。
```C++
*p.size(); //错误：p是一个指针，它没有名为size的成员
```
点运算符的优先级高，先算p.size()然后将结果解引用，这样含义改变了。

箭头运算符作用与一个指针类型的运算对象，结果是一个左值。
点运算符则是：如果成员所属的对象是左值，那么结果是左值。如果成员所属的对象是右值，那么结果是右值。

# 条件运算符

条件运算符(?:)允许我们把简单的if-else逻辑嵌入到单个表达式中。

cond ? expr1 : expr2

cond是条件判断的表达式，而expr1和expr2是两个类型相同或者可能转换为某个公共类型的表达式。
先求cond的值，如果条件为真，对expr1求值并返回该值，否则对expr2求值并返回该值。

当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算结果是左值，否则运算的结果是右值。

## 嵌套条件运算符

允许在条件运算符的内部嵌套另外一个条件运算符。
在这个情况下，你会十分想念传统的if-else语句，并且抱着括号的大腿。

条件运算符满足右结合律，意味着。。。（我不懂了）

> 随着条件运算嵌套层数的增加，代码的可读性急剧下降。因此，条件运算符的嵌套最好别超过两到三层。

条件运算符的优先级也是非常低的哟！

# 位运算符

位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。
位运算符提供检查和设置二进制位的功能，另外还有bitset也是专门做这个的。

|运算符|功能|用法|
|:---:|:--:|:---:|
|~|位求反| ~expr |

|运算符|功能|用法|
|:---:|:--:|:---:|
|<<|左移| expr1 << expr2 |
|>>|右移| expr1 >> expr2 |

|运算符|功能|用法|
|:---:|:--:|:---:|
|&|位与| expr & expr |

|运算符|功能|用法|
|:---:|:--:|:---:|
|^|位异或| expr ^ expr |

|运算符|功能|用法|
|:---:|:--:|:---:|
|`|`|位或|`expr | expr`|

一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。
带符号类型，其符号位如何处理，依赖具体实现。

> 关于符号位如何处理没有明确规定，所以建议仅将位运算符用于处理无符号类型。

## 移位运算符

将运算对象执行基于二进制位的移动操作，令左侧运算对象的内容按照右侧运算对象的要求移动指定位数。
超出边界的位被舍弃，不足的用0补充。

符号位的处理，依赖具体实现。

## 位求反运算符

将运算对象的每个位求反后产生一个新值，每个位0变成1,1变成0。

## 移位运算符满足左结合律

它的重载版本也叫IO运算符，你用过的，左结合哟。

# sizeof运算符

sizeof运算符返回一条件表达式或者一个类型名字所占的字节数。
满足右结合律。所得的值是size_t类型的常量表达式。

sizeof(type)
sizeof expr

第二种形式中，sizeof返回的是表达式结果类型的大小。sizeof并不实际计算其运算对象的值。（分析么）

C++11允许使用作用域运算符来获取类成员的大小，不用提供一个具体的对象，因为它不需要实际求值。

sizeof运算符的结果部分的依赖于其作用的类型：
* 对char或者类型为char的表达式执行sizeof运算，结果为1。
* 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
* 对指针执行sizeof运算的到指针本身所占空间的大小。
* 对解引用指针执行sizeof运算得到指针所指的对象所占空间的大小，指针不需有效。
* 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将结果求和。注意：sizeof运算不会把数组转换成指针来处理。
* 对string对象或者vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数。

# 逗号运算符

逗号运算符(comma operator)，规定了运算对象的求值顺序。
从左向右的顺序依次求值。
首先对左侧的表达式求值，然后将求值结果丢弃（副作用肯定是有的）。逗号运算符真正的结果是右侧表达式的值。
如果右侧运算对象是左值，那么最终的求值结果也是左值。

# 类型转换

有些类型可以将值互相转换(conversion)，他们互相关联。

有的转换是自动执行的，无须程序员的介入，被称作隐式转换(implicit conversion)。

算术类型之间的隐式转换被设计的尽可能避免损失精度。

## 何时发生隐式转换

* 大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
* 在条件中，非布尔值转换为布尔类型。
* 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧对象转换成左侧对象的类型。
* 如果算术运算或者关系运算对象有多种类型，需要转换成同一种类型。
* 函数调用时也会发生类型转换。

## 算术转换

算术转换(arithmetic conversion)的含义是把一种算术类型转换成另一种算术类型。

整形提升(integral promotion)把小整数类型转换成较大的整数类型。只要能存在int里，就会提升成int类型。否则，就是unsigned int。

## 其他隐式类型转换

数组转换成指针：大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针
```C++
int ia[10];
itn *p = ia; //ia -> &ia[0]
```
当数组被用作decltype关键字的参数，或者作为取地址符(&)，sizeof，typeid等运算符的运算对象时，该转换不会发生。
用引用来初始化数组，该转换也不会发生。
表达式中使用函数类型时也会发生类似的指针转换。

指针的转换：常量整数值0或者字面值nullptr能转换成任意指针类型。
指向任意非常量的指针能转换成void*。
指向任意对象的指针能转换成const void*。

转换成布尔类型：算术类型或指针类型，如果值为0，转换为false，否则就是true。

转换成常量：允许将指向非常量类型的指针转换成指向相应类型的常量类型的指针，引用也是这样。
相反的转换并不存在，因为它试图删除掉底层const。（除非const_cast）

类类型定义的转换：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。

## 显式转换

有时我们希望显式的将对象强制转换成另外一种类型。
这叫强制类型转换(cast)。

> 虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。

强制类型转换具有以下形式：

`cast-name<type>(expression);`

type是转换的目标类型，expression是要转换的值。如果type是引用类型，则结果是左值。
cast-name有：static_cast, dynamic_cast, const_cast, reinterpret_cast。
dynamic_cast支持运行时类型识别。

### static_cast

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。
对于编译器无法自动执行的类型转换非常有用。
我们可以用来找回存在于void*的指针。

```C++
void *p = &d;
double *dp = static_cast<double*>(p);
```

用强制类型转换会原来的类型时，一定要转换回原来的类型，类型一旦不符，将产生未定义的后果。

### const_cast

只改变运算对象的底层const。

```C++
const char *pc;
char *p = const_cast<char*>(pc); //正确：但是通过p写值是未定义的行为。
```

将常量对象转换成非常量的行为，我们一般称其为去掉const性质(cast away the const)。
去掉了const性质，编译器不在阻止我们写值。如果对象本身不是常量，这么做就是合法的。
如果对象本身就是常量，再使用const_cast对其写值就是未定义的行为。

只有const_cast能改变表达式的常量属性，使用其他形式的转换将报错。
也不能用const_cast改变表达式的类型。

const_cast 常常用于有函数重载的上下文中。

### reinterpret_cast

为运算对象的位模式提供较低层次上的重新解释。

这个转换非常危险！！！
重新解释类型的哟！编译器不会阻止你的！！！乱来就都是未定义行为哟！！！

> reinterpret_cast本质上依赖于及其。要想安全使用，必须对涉及的类型和编译器实现转换的过程都非常的了解。

> 建议：避免强制类型转换
> 强制类型转换干扰了正常的类型检查，因此我们强烈建议程序员避免使用强制类型转换。特别是reinterpret_cast。每次书写了一条强制类型转换语句，都应该反复斟酌能否以其他方式实现相同的目标。就算实在无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定个，这样可以减少错误发生的机会。

## 旧式的强制类型转换

type (expr); //函数形式的强制类型转换
(type) expr; //C语言风格的强制类型转换

如果替换成static_cast或者const_cast也合法，则拥有他们的行为。
但是如果替换不合法，就拥有reinterpret_cast的行为。

> 旧式的转换十分可怕，请不要随意使用。。。和reinterpret_cast等效的哟！！！

# 运算符优先级表

