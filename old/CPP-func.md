---
title: C++ 函数
date: 2018-07-23 22:16:36
tags:
- C++
---

函数是一个命名的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。可以重载函数，也就是说，同一个名字可以对应多个不同的函数。

# 函数基础

一个典型的函数(function)定义包括以下部分：返回类型(return type)，函数名字，由0个或多个形参(parameter)组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对圆括号之内。函数执行的操作在语句块中说明，该语句块称为函数体(function body)。

我们通过调用运算符(call operator)来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针：圆括号之内是一个用逗号隔开的实参(argument)列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。

```C++
//编写函数

//阶乘
int fact(int val)
{
    int ret = 1;
    while (val > 1)
        ret *= val--;
    return ret;
}

//调用函数

int main()
{
    int j = fact(5);
    std::cout<<"5! = "<<j<<std::endl;
    return 0;
}
```

函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将函数控制权转移给被调用函数。
此时，主调函数(calling function)的执行被暂时中断，被调函数(called function)开始执行。

执行函数的第一步是（隐式的）定义并初始化它的形参。

当遇到一条return语句时函数结束执行过程。
和函数调用一样，return语句也完成两项工作：一是返回return语句中的值（如果有的话），二是将控制权从被调函数转移回主调函数。函数的初始值用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分。

### 形参与实参

实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。

实参的类型必须与对应的形参类型匹配。实参和形参的数量也必须相同（也有其他情况）。所以形参一定会被初始化。
（实参的类型能隐式转换到形参类型也能直接调用）

### 函数的形参列表

函数的形参列表可以为空，但是不能省略。要想定义一个不带形参的函数，最常用的办法是书写一个空的形参列表。不过为了与C语言兼容，也可以使用关键字void表示函数没有形参

```C++
void f1(){...}
void f2(void){...}
```

形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来

```C++
int f3(int v1, v2){...} //错误！
int f4(int v1, int v2){...} //正确
```

任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。

形参名是可选的，但是由于我们无法使用未命名的形参，所以形参列表一般都应该有个名字。偶尔，函数确实有个别形参不会被用到，则此类形参通常不命名以表示在函数体内不会使用它。不管怎样，是否设置未命名的形参并不影响调用时提供的实参数量。即使某个形参不被函数使用，也必须为它提供一个实参。

### 函数返回类型

大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何值。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。

## 局部对象

C++中，名字有作用域，对象有生命周期(lifetime)。
* 名字的作用域是程序文本的一部分，名字在其中可见。
* 名字的生命周期是程序执行过程中该对象存在的一段时间。

函数体是一个语句块。块构成一个新的作用域，我们可以在其中定义变量。形参和函数体内部定义的变量统称为局部变量(local variable)。他们对函数来说是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏(hide)在外层作用域中同名的其他所有声明中。

在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，知道程序结束才会销毁。局部变量的声明周期依赖于定义的方式。

### 自动对象

对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的快末尾时销毁他。我们把只存在于块执行期间的对象成为自动对象(automatic object)。当块的执行结束后，块中创建的自动对象就变成未定义的了。

形参是一种自动对象。函数开始时为形参申请储存空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁。

我们用传递给函数的实参初始化形参对应的自动对象。对于局部变量对应的自动对象来说，则分为两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化。这意味着内置类型的未初始化局部变量将产生未定义的值。

### 局部静态对象

令局部变量的生命周期贯穿函数调用之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态变量(local static object)在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它产生影响。

比如统计调用次数。。。

```C++
size_t count_calls()
{
    static size_t ctr = 0;
    return ++ctr;
}

int main()
{
    for(size_t i = 0; i != 10; ++i)
    {
        std::cout << count_calls() << std::endl;
    }
    return 0;
}
```

如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0.

## 函数声明

函数的名字也必须在使用之前声明。函数只能定义一次（唯一定义原则），但可以声明多次。唯一的例外是重载么。如果一个函数永远也不会被我们用到，那么它可以只有声明没有定义。

函数的声明和函数的定义非常类似，唯一的区别是函数声明无需函数体，用一个分号替代。

因为函数的声明不包含函数体，所以也就无需形参的名字。事实上，在函数的声明中经常省略形参的名字。
尽管如此，写上形参的名字还是有好处的，它可以帮助使用者更好的理解函数的功能。

```C++
void visit(int *b, int*e);
```

函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。
函数声明也被称作函数原型(function prototype)。

### 在头文件中进行函数声明

我们建议函数也应该在头文件中声明而在源文件中定义。

定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。

> 含有函数声明的头文件应该被包含到定义函数的源文件中。

# 参数传递

每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。

> 形参初始化的机理与变量初始化一样。

形参的类型决定了形参和实参交互的方式。
如果形参是引用类型，它将绑定到对应的实参上。否则，将实参的值拷贝后赋给形参。

当形参是引用类型时，我们说它对应的实参被引用传递(passed by reference)或者函数被传引用调用(called by reference)。和其他引用一样，引用形参也是他绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。

当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递(passed by value)或者函数被传值调用(called by value)。

## 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。

传值参数的机制完全一样，函数对形参做的所有操作都不会影响实参。

### 指针形参

指针形参的行为和其他费引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。

> 熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参替代指针。

## 传引用参数

使用引用形参，允许函数改变一个或多个实参的值。

### 使用引用避免拷贝

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（比如IO类型）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。

> 如果函数无须改变引用形参的值，最好将其声明为常量引用。
### 使用引用形参返回额外的信息

一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。

就是有些参数，传进去是用来让函数去改的，函数改后的值当做函数的“返回值”。

## const形参和实参

当形参是const时，必须要注意关于顶层const的讨论。
和其他初始化一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。
当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。

```C++
void fcn(const int i) { /*fcn 能够读取i，但是不能向i写值*/ }
```

调用fcn函数时，既可以传入const int 也可以传入int。忽略掉形参的顶层const可能产生意想不到的结果。

```C++
void fcn(const int i) { /*fcn 能够读取i，但是不能向i写值*/ }
void fcn(int i){ /*错误：重复定义了fcn(int)*/ }
```

C++语言中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别。因为顶层cosnt被忽略掉了，所以在上面的代码中传入两个fcn函数的参数可以完全一样。因此第二个fcn是错误的，尽管形式上有差异，但实际上它的形参和第一个fcn形参没什么不同。

### 指针或引用形参与const

形参的初始化方式和变量的初始化方式是一样的。
我们可以使用非常量初始化一个底层const对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。

### 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。
此外，使用引用而非对常量的引用也会极大地限制函数所能接收的实参类型。
就像，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

（P192）

## 数组形参

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组 以及使用数组时（通常）会将其转换成指针。因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。

尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：

```C++
//尽管形式不同，但这三个print函数是等价的
//每个函数都有一个const int*类型的形参
void print(const int*);
void print(const int[]);   //可以看出来，函数的意图是作用与一个数组
void print(const int[10]); //这里的维度表示我们期望数组含有多少元素，实际不一定
```

尽管表现形式不同，但是上面的三个函数是等价的：每个函数的唯一形参都是`const int*`类型的。当编译器处理对print函数的调用时，只检查传入的参数是否是`const int*`类型。

```C++
int i = 0;
int j[2] = {0,1};

print(&i); //正确：&i的类型是int*
print(j);  //正确：j转换成int*并指向j[0]
```

如果我们传给print函数的是一个数组，则实参自动的转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。

> 和其他使用数组的代码一样，以数组作为形参的参数也必须确保使用数组的时候不会越界。

因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术。

### 使用标记指定数组长度

管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。
C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符停止：

```C++
void print(const char *cp)
{
    if (cp) //如果cp不是一个空指针
        while(*cp) //只要指针所指的字符不是空字符
            std::cout << *cp++; //输出当前字符并将指针向前移动一个位置
}
```

这种方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况，但是对于像int这样所有取值都是合法值的数据就不太有效了。

### 使用标准库规范

管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库技术的启发。

```C++
void print(const int *beg, const int *end)
{
    //输出beg到end之间（不含end）的所有元素
    while (beg != end)
        std::endl << *beg++ << std::endl;
}
```

为了调用这个函数，我们需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一位置。

```C++
int j[2] = {0,1};

print(begin(j), end(j));
```

只要调用者能正确的计算指针所指的位置，那么上述代码就是安全的。在这里，我们使用标准库begin和end函数提供所需的指针。

###  显式传递一个表示数组大小的形参

第三种管理数组实参的方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。

```C++
//const int ia[]等价于const int* ia
//size表示数组的大小，将它显式的传给函数用于控制对ia元素的访问
void print(const int ia[], size_t size)
{
    for(size_t i = 0 ; i != size ; ++i)
    {
        std::cout << ia[i] << std::endl;
    }
}
```

通过形参size的值确定要输出多少个元素，调用print函数时必须传入这个表示数组大小的值

```C++
int j[] = {0,1};

print(j, end(j) - begin(j));
```

只要传递给函数的size值不超过数组实际的大小，函数就是安全的。

### 数组形参和const

当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。

### 数组引用形参

C++语言允许将变量定义成数组的引用，所以，形参也可以是数组的引用。此时，引用形参绑定到相应的实参上，也就是绑定到数组上。

```C++
//正确：形参是数组的引用，维度是类型的一部分
void print(int (&arr)[10])
{
    for (auto elem : arr)
        std::cout << elem << std::endl;
}
```

> &arr两端的括号必不可少
> f(int &arr[10])   //错误：将arr声明成了引用的数组
> f(int (&arr)[10]) //正确：arr是具有10个整数的整型数组的引用

因为数组大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心的使用数组。但是，这一用法也无形的限制了print函数的可用性，我们只能将函数作用于大小为10的数组。

```C++
int i = 0;
int j[2] = {0,1};
int k[10] = {0,1,2,3,4,5,6,7,8,9};

print(&i); //错误：实参不是含有10个整数的数组
print(j);  //错误：实参不是含有10个整数的数组
print(k);  //正确：实参是含有10个整数的数组
```

### 传递多维数组

当我们把多维数组传递给函数时，真正传递的是指向数组首元素的指针。
因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。
数组第二维（以及后面所有的维度）的大小都是数组类型的一部分，不能忽略。

```C++
void print(int (*matrix)[10], int rowSize) { ... }
```

matrix声明成指向含有10个整数的数组的指针。

> 再一次强调，*matrix两端的括号必不可少
> int *matrix[10];   //10个指针构成的数组
> int (*matrix)[10]; //指向含有10个整数的数组的指针

我们也可以使用数组的语法定义函数，此时编译器会一如既往的忽略掉第一个维度，所以最好不要把它包括在形参列表内

```C++
//等价定义
void print(int matrix[][10], int rowSize) { ... }
```

matrix的声明看起来是一个二维数组，实际上形参是指向含有10整数的数组的指针。

我：普通数组类型当做形参。。。值传递又无效。。。指定个默认值。。。做占位符？

## main：处理命令行选项

目前，我们定义的main函数都只有空形参列表。

```C++
int main() { ... }
```

然而，有时我们确实需要给main传递实参，那就是命令行参数。
比如一个程序的名字是prog，我们可以传递命令行选项

```sh
prog -d -o ofile data0
```

这些命令行通过两个（可选的）形参传递给main函数

```C++
int main(int argc, char *argv[]) { ... }
```

第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；
第一个形参argc表示数组中字符串的数量。

因为第二个形参是数组，所以main函数也可以定义成

```C++
int main(int argc, char **argv) { ... }
```

其中argv指向char*。

当实参传给main之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

上面的命令行为例子的话，argc=5，argv应该是下面这样：

```C++
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

> 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始;argv[0]保存程序的名字，而非用户输入。

## 含有可变形参的函数

有时我们无法提前预知应该向函数传递几个实参。

为了编写能处理不同数量实参的函数，C++11新标准提供了两个主要的方法：
* 如果所有的实参类型相同，可以传递一个叫initializer_list的标准库类型；
* 如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板。

C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。不过需要注意的是，这种功能一般只用于与C函数交互的接口程序。

### initializer_list形参

如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的实参。这是一种标准库类型，用于标识某种特定类型的值的数组。定义在`<initializer_list>`中。

操作列表

initializer_list<T> lst;
默认初始化；T类型元素的空列表

initializer_list<T> lst{a,b,c...};
lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const

lst2(lst)
lst2 = lst
拷贝或者赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。

lst.size()
列表中元素数量

lst.begin()
返回指向lst中首元素的指针

lst.end()
返回指向lst中尾后元素的指针

initializer_list是模板类型，定义该对象时，必须说明列表中所含元素的类型。
该对象中的元素永远是常量值，我们无法改变该对象中元素的值。

我们可以这么用

```C++
void error_msg(initializer_list<string> il)
{
    for (auto beg = il.begin() ; beg != il.end() ; ++beg)
        std::cout << *beg << " ";
    std::cout << std::endl;
}
```

如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内

```C++
error_msg({"bla", "bla", "bla"});
```

含有initializer_list形参的函数也可以同时拥有其他形参。
对应的实参用{}传递个序列就行。

因为initializer_list包含begin和end成员，所以我们可以使用范围for循环处理其中的元素。

### 省略符形参

省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。通常，省略符形参不应用于其他目的。你的C编译器文档会描述如何使用varargs。

> 省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。

省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：
* `void foo(param_list, ...);`
* `void foo(...);`

第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。
省略符形参所对应的实参无须类型检查。
在第一种形式中，形参声明后面的逗号是可选的。

# 返回类型和return语句

return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。
return语句有两种形式。

```C++
return;
return expression;
```

## 无返回值函数

没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为这类函数的最后一句后面会隐式的执行return。

通常情况下，void函数如果想在它的中间位置提前退出，可以使用return语句。

```C++
void func()
{
    ...
    return;
    ...
}
```

一个返回类型是void的函数也能使用return语句的第二形式，不过此时return语句的expression必须是另一个返回void的函数。强行令void函数返回其他类型的表达式将产生编译错误。

## 有返回值的函数

return语句的第二种形式提供了函数的结果。只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句返回值的返回类型必须与函数的返回类型相同，或者能隐式转换成函数的返回类型。

尽管C++无法确保结果的正确性，但是可以保证每个return语句的结果类型正确。也许无法顾及所有情况，但是编译器仍然尽量确保具有返回值的函数只能通过一条有效的return语句退出。

如果函数某个执行路径缺少了return语句（函数体内部含有return语句），编译器可能无法发现这个错误，那么这条执行路径将会是未定义的。

> 在含有return语句的循环后面应该也有一条return语句，如果没有的话改程序就是错误的。很多编译器都无法发现此类错误。

### 值是如何被返回的

返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。

必须注意当函数返回局部变量是的初始化规则。

返回类型是非常量，意味着返回值将被拷贝到调用点。因此，函数会返回副本或者一个未命名的临时对象。

同其他引用类型一样，如果函数返回引用，则该引用仅是它所指对象的一个别名。

### 不要返回局部对象的引用或指针

函数完成后，它所占用的储存空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。

```C++
const string &manip()
{
    string ret;
    if (!ret.empty())
        return ret; //错误：返回局部对象的引用
    else
        return "Empty"; //错误："Empty"是一个局部临时量
}
```

> 要想确保返回值安全，我们不妨提问：引用所引的是在函数之前已经存在的哪个对象？

返回局部对象的引用是错误的；同样，返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。

### 返回类类型的函数和调用运算符

和其他运算符一样，调用运算符也有优先级和结合律。调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。因此，如果函数返回指针、引用或者类的对象，我们就能使用函数调用的结果访问结果对象的成员。

### 引用返回左值

函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以向其他使用左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值。

```C++
char &get_val(string &str, string::size_type ix)
{
    return str[ix];
}

int main()
{
    string s("a value");
    std::cout<<s<<std::endl;
    get_val(s, 0) = 'A';
    std::cout<<s<<std::endl;
    return 0;
}
```

把函数调用放在赋值语句的左侧可能看起来有点奇怪，但其实这没什么特别的。返回值是引用，因此调用是个左值，和其他左值一样它能出现在赋值运算符的左值。

如果返回类型是常量引用，我们不能给调用的结果赋值。

### 列表初始化返回值

C++11新标准规定，函数可以返回花括号包围的值的列表。
此处的列表也用来对表示函数返回的临时量进行初始化。
如果列表为空，临时量执行值初始化；否则，返回值由函数的返回类型决定。

```C++
vector<string> func()
{
    return {}; //返回空vector
    return {"you", "know"}; //返回列表初始化的vector对象
}
```

如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，由类本身定义初始值该如何使用。

### 主函数main的返回值

main函数的返回值有特殊含义。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。
为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，我们可以使用这两个变量分别表示成功与失败。

EXIT_SUCCESS; //成功
EXIT_FAILURE; //失败

### 递归

如果一个函数调用了它自身，不管这种调用是直接的还是间接地，都称该函数为递归函数(recursive function)。

```C++
int factorial(int val)
{
    if (val > 1)
        return factorial(val-1) * val;
    return 1;
}
```

在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。我们有时候会说这种函数含有递归循环(recursion loop)。在factorial函数中，递归终止的条件是val等于1.

下面的表格显示了当给factorial函数传入参数5时，函数的执行轨迹。

|调用|返回|值|
|:--|:--|:--|
|factorial(5)|factorial(4) * 5|120|
|factorial(4)|factorial(3) * 4|24|
|factorial(3)|factorial(2) * 3|6|
|factorial(2)|factorial(1) * 2|2|
|factorial(1)|1|1|

> main函数不能调用它自己。

## 返回数组指针

因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。
虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较繁琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名。

```C++
typedef int arrT[10];

using arrT = int[10];
arrT *func(int i); //func: int -> arrT*
```

arrT是含有10个整数的数组的别名。因为我们无法返回数组，所以将返回类型定义成数组的指针。

### 声明一个返回数组指针的函数

要想在声明func时不使用类型别名，我们必须牢记被定义的名字后面数组的维度：

```C++
int arr[10]; //arr是一个含有10个整数的数组
int *p1[10]; //p1是一个含有10个指针的数组
int (*p2)[10] = &arr; //p2是一个指针，它指向含有10个整数的数组
```

和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。
然而，函数形参列表也跟在函数名字后面且形参列表应该先于数组的维度。
因此，返回数组指针的函数形式如下：
Type(*function(parameter_list))[dimension]
类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。(*function(parameter_list))两端的括号必须存在，就像我们定义p2时两端必须有括号一样。如果没有这对括号，函数的返回类型将是指针的数组。

举个具体点的例子，下面这个func函数的声明没有使用类型别名：
`int (*func(int i))[10]`
可以按照以下的顺序来逐层理解该声明的含义：
* func(int i)表示调用func函数时，需要一个int类型的实参。
* (*func(int i))意味着我们可以对函数调用的结果执行解引用操作。
* (*func(int i))[10]表示解引用func的调用将得到一个大小是10的数组。
* int (*func(int i))[10]表示数组中的元素是int类型。

### 使用尾置返回类型

C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型(trailing return type)。
任何函数的定义都能尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。
尾置返回类型跟在形参列表后面并以一个->符号开头。
为了表示函数真正的返回类型在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：

```C++
auto func(int i) -> int(*)[10];

因为我们把函数的返回类型放在了形参列表之后，所以可以清楚的看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。

### 使用decltype

还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用的decltype关键字声明返回类型。

```C++
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
//返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i)
{
    return (i % 2) ? &odd : &even; //返回一个指向数组的指针
}
```

arrPtr使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与odd的类型一致。
因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。
有个地方需要注意：decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个*符号。

# 函数重载

如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载(overloaded)函数。

```C++
void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);
```

这些函数接收的形参类型不一样，但是执行的操作非常类似。
当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。

```C++
int j[2] = {0,1};
print("hello, world!"); //调用print(const char *)
print(j, end(j) - begin(j)); //调用print(const int*, size_t)
print(begin(j), end(j)); //调用print(const int*, const int*)
```

函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。

> main函数不能重载

### 定义重载函数

比如有个lookup的函数，能根据不同的信息查找记录。

```C++
Record lookup(const Account&);
Record lookup(const Phone&);
Record lookup(const Name&);

Account acct;
Phone phone;

Record r1 = lookup(acct);  //Account 版本
Record r2 = lookup(phone); //Phone 版本
```

虽然我们定义的三个函数各不相同，但它们都有一个名字。编译器根据实参的类型确定应该调用哪一个函数。

对于重载函数来说，它们应该在形参数量或形参类型上有所不同。

不允许两个函数除了返回类型外其他所有要素都相同。

### 判断两个形参的类型是否相异

有时候两个形参列表看起来不一样，但实际上是相同的。

```C++
Record lookup(const Account &acct);
Record lookup(const Account &);
//忽略了形参名字

typedef Phone Telno;
Record lookup(const Phone&);
Record lookup(const Telno&);
//Telno和Phone类型相同
```

第一对声明里面，形参的名字仅仅起到帮助记忆的作用，并不影响形参列表的内容。

第二对声明看起来类型不同，但事实上Telno不是一种新类型，它只是Phone的别名而已。类型别名为已存在的类型提供另外一种名字，它并不是创建新类型。所以它们本质上来说没什么不同。

### 重载和const形参

顶层const不影响传入函数的对象。
一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。

```C++
Record lookup(Phone);
Record lookup(const Phone); //重复声明了Record lookup(Phone)

Record lookup(Phone*);
Record lookup(Phone* const);//重复声明了Record lookup(Phone*)
```

如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时const是底层的。

```C++
//对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同
//定义了4个独立的函数重载
Record lookup(Account&);  //函数作用于Account的引用
Record lookup(const Account&); //新函数，作用于常量引用

Record lookup(Account*); //新函数，作用于指向Account的指针
Record lookup(const Account*); //新函数，作用于指向常量的指针
```

编译器可以通过实参是否是常量来推断应该调用哪个函数。因为const不能转换成其他类型，所以我们只能把const对象（或指向const的指针）传递给const形参。
相反的，因为非常量可以转换成const，所以上面的4个函数对象都能作用于非常量对象或者指向非常量对象的指针。
不过，当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。

### const_cast和重载

我们说过，const_cast在重载函数的情景中最有用。

比如有函数：
```C++
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```

这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string的引用。
因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点：

```C++
string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```

这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始值的非常量实参上。因此，我们可以再将其转换回一个普通的string&，这显然是安全的。

### 调用重载的函数

定义了一组重载函数后，我们需要以合理的实参调用它们。
函数匹配(function matching)是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定(overload resolution)。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。

大多数情况下，程序员能够判断重载时，函数调用是否合法，会调用哪个函数。
但是，一些情况下，判断函数匹配就比较困难了。比如当两个重载函数参数数量相同且参数类型可以相互转换时。

当调用重载函数时有三种可能的结果：
* 编译器找到一个与实参最佳匹配(best match)的函数，并生成调用该函数的代码。
* 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配(no match)的错误信息。
* 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用(ambiguous call)。

## 重载和作用域

> 一般来说，将函数声明置于局部作用域内不是一个明智的选择。但是为了说明作用域和重载的相互关系，我们将暂时违反这一原则而使用局部函数声明。

重载对作用域的一般性质并没有什么改变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名：

```C++
string read();
void print(const string &);
void print(double); //重载print函数
vlid fooBar(int ival)
{
    bool read = false; //新作用域：隐藏了外层的read
    string s = read(); //错误：read是一个布尔值，而非函数
    //不好的习惯：通常来说，局部作用域中声明函数不是一个好的选择（然而lambda表达式的匿名函数是在打脸吗？）
    void print(int); //新作用域：隐藏了之前的print
    print("Value: ); //错误：print(const string &);被隐藏掉了
    print(ival); //正确：当前print(int)可见
    print(3.14); //正确：调用print(int)；void print(double)被隐藏掉了
}
```

调用print函数时，在fooBar内声明的print(int)隐藏了之前两个print函数，因此只有一个print函数是可用的：该函数以int值作为参数。

当我们调用print函数时，编译器首先寻找对该函数名的声明，找到的是接受int值的那个局部声明。一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。剩下的工作就是检查函数调用是否有效了。

> 在C++语言中，名字查找发生在类型检查之前。

第一个调用传入一个字符串字面值，但是当前作用域内print函数唯一的声明要求参数是int类型。字符串字面值无法转换成int类型，所以这个调用是错误的。在外层作用域中的print(const string&)函数虽然与本次调用匹配，但是它已经被隐藏掉了，根本不会被考虑。

当我们为print函数传入一个double类型的值时，重复上述过程。编译器在当前作用域内发现了print(int)函数，double类型的实参转换成int类型，因此调用是合法的。

假设我们把print(int)和其他print函数声明放在同一个作用域中，则它将成为另一种重载形式。
此时，因为编译器能看到的所有三个函数，上述调用的处理结果将完全不同。

```C++
void print(const string &);
void print(double); //print函数的重载
void print(int); //print函数的重载

void fooBar2(int ival)
{
    print("Value: "); //调用print(const string &)
    print(ival); //调用print(int)
    print(3.14); //调用print(double)
}
```

# 特殊用途语言特性

## 默认实参

这些函数有这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的默认实参(default argument)。调用含有默认实参的函数时，我们可以包含该实参，也可以忽略该实参。

例子：

```C++
typedef string::size_type sz;

string screen(sz ht = 24, sz wid = 80, char backgrnd= ' ');
```

其中我们为每一个形参都提供了默认实参，默认实参作为形参的初始值出现在形参列表中。我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

### 使用默认实参调用函数

如果我们想使用默认实参，只要在调用函数的时候忽略该实参就可以了。

```C++
string window;

window = screen();             //screen(24, 80, ' ')
window = screen(66);           //screen(66, 80, ' ')
window = screen(66, 256);      //screen(66, 256, ' ')
window = screen(66, 256, '#'); //screen(66, 256, '#')
```

函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）。
例如，要想覆盖backgrnd的默认值，必须为ht和wid提供实参。

```C++
window = screen(, , '?'); //错误：只能省略尾部的实参
window = screen('?'); //调用screen('?', 80, ' ');
```

需要注意，第二个调用传递一个字符值，是合法的调用。然而尽管如此，它的实际效果却与书写的意图不符。该调用发生隐式转换。

当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。

### 默认实参声明

对于函数的声明来说，通常的习惯是将其放在头文件中，并且每个函数只声明一次，但是多次声明同一个函数也是合法的。
不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认形参。
换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

加入给定：

```C++
// 表示高度和宽度的形参没有默认值
string screen(sz, sz, char = ' ');
```

我们不能修改一个已经存在的默认值：

```C++
string screen(sz, sz, char = '*'); //错误：重复声明
```

但是可以按照如下形式添加默认实参：

```C++
string screen(sz = 24, sz = 80, char); //正确：添加默认实参
```

> 通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。

### 默认实参初始值

局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：

```C++
// wd, def, ht的声明必须出现在函数之外
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);
string window = screen(); //调用screen(ht(), 80, ' ')
```

用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：

```C++
void f2()
{
    def = '*';         //改变默认实参的值
    sz wd = 1000;      //隐藏了外层定义的wd，但是没有改变默认值
    window = screen(); //调用 screen(ht(), 80, '*')
}
```

我们在函数f2内部改变了def的值，所以对screen的调用将会传递这个更新过的值。另一方面，虽然我们的函数还声明了一个局部变量用于隐藏外层的wd，但是该局部变量与传递给screen的默认实参并没有任何关系。

## 内联函数

把规模较小的操作定义成函数有很多好处，主要包括：
* 阅读和理解函数调用要比读懂等价的条件表达式容易的多。
* 使用函数可以确保行为统一，每次相关操作都能保证按照同样的方式进行。
* 如果我们需要修改计算过程，显然修改函数要比先找到等价表达式所有出现的地方再逐一修改更容易。
* 函数可以被其他应用重复利用，省去了程序员重新编写的代价。

然而，也存在一个潜在的缺点：调用函数一般比求等价表达式的值要慢一些。
在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序专项一个新的位置继续执行。

### 内联函数可以避免函数调用的开销

将函数指定为内联函数(inline)，通常就是将它在每个调用点上“内联的”展开。

在函数返回类型前面加上关键字`inline`，这样就可以将它声明成内联函数了。

> 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。

一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。
很多编译器都不支持内联递归函数，而且一个很多行的函数也不大可能在调用点内联的展开。

## constexpr函数

constexpr函数(constexpr function)是指能用于常量表达式的函数。
定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：
* 函数的返回类型及所有形参的类型都得是字面值类型。
* 函数体中必须有且仅有一条return语句

```C++
constexpr int new_sz() {return 42;}
constexpr int foo = new_sz(); //正确：foo是一个常量表达式
```

我们把new_sz定义成无参数的constexpr函数。因为编译器能在程序编译时验证new_sz函数返回的是常量表达式，所以我们可以用new_sz函数初始化constexpr类型的变量foo。

执行该初始化人物时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式的指定为内敛函数。

cosntexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。
constexpr函数中可以有空语句，类型别名，以及using声明。

我们允许constexpr函数的返回值并非一个常量

```C++
//如果arg是常量表达式，则scale(arg)也是常量表达式
constexpr size_t scale(size_t cnt){return new_sz() * cnt;}
```

当scale的实参是常量表达式时，它的返回值也是常量表达式，反之则不然。

```C++
int arr[scale(2)]; //正确：scale(2)是常量表达式
int i = 2; //i不是常量表达式
int a2[scale(i)]; //错误：scale(i)不是常量表达式
```

如果我们用一个非常量表达式调用scale函数，比如int类型的对象i，则返回值是一个非常量表达式。
当把scale函数用在需要常量表达式的上下文中，由编译器负责检查函数的结果是否符合要求。如果结果恰好不是常量表达式，编译器将发出错误信息。

> constexpr函数不一定返回常量表达式。

### 把内联函数和constexpr函数放在头文件内

和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。
毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。
不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。
基于这个原因，内联函数和constexpr函数通常定义在头文件中。

## 调试帮助

程序可以包含一些用于调试的代码，但是这些代码只在开发的时候使用。
当应用程序编写完成准备发布时，要先屏蔽掉调试代码。
比如：assert和NDEBUG。

### assert预处理宏

assert是一种预处理宏(preprocessor marco)。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。
assert宏使用一个表达式作为它的条件。

assert(expr);

首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。
如果表达式为真（即非0），assert什么也不做。

assert宏定义在`<cassert>`头文件中。预处理名子由预处理器而非编译器管理，所以无需提供using声明。

和预处理变量一样，宏名字在程序内必须唯一。含有cassert头文件不能再定义名为assert的变量、函数或者其他实体。
实际编程过程中，即使我们没有包含cassert头文件，也最好不要为了其他目的使用assert。很多头文件都包含了cassert，这就意味着即使你没有直接包含cassert，也很有可能通过其他途径包含在你的程序中。

assert宏常用于检查“不能发生”的条件。

### NDEBUG预处理变量

assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。

我们可以使用一个`#define`定义NDEBUG，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量。

```sh
$ CC -D NDEBUG main.c
```

等价于main.c文件的一开始写`#define NDEBUG`。

定义NDEBUG能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。
因此，assert应该仅用于验证那些确实不可能发生的事情。
我们可以吧assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时检查，也不能替代程序本身应该包含的错误检查。

我们也可以自己用NDEBUG编写自己的条件调试代码
如果NDEBUG未定义，将执行`#ifndef`和`#endif`的代码；如果定义了NDEBUG，这些代码将被忽略掉。

```C++
...
#ifndef NDEBUG
//这里写调试代码
#endif
...
```

预处理器定义了一些对于调试很有用的名字

`__func__`当前函数的名字
`__FILE__`存放文件名的字符串字面值
`__LINE__`存放当前行号的整型字面值
`__TIME__`存放文件编译时间的字符串字面值
`__DATE__`存放文件编译日期的字符串字面值

# 函数匹配

在大多数情况下，我们很容易确地某次调用应该选用那个重载函数。
然而，当几个重载函数的形参数量相等以及某些形参的类型可以由其他类型转换而来时，这项工作就不那么容易了。

比如下面这组函数及其调用

```C++
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);

f(5.6); //调用void f(double, double)
```

### 确定候选函数和可行函数

函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数(candidate function)。
候选函数具有特征：
* 与被调用的函数同名
* 其声明在调用点可见。

这个例子中，有4个名为f的候选函数。

第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数成为可行函数(viable function)。
可行函数具有特征：
* 形参数量与本次调用提供的实参数量相等
* 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。

我们能根据实参的数量从候选函数中派出掉两个。不使用形参的函数和使用两个int形参的函数显然都不适合本次调用，这是因为我们的调用只提供了一个实参，而它们分别有0个和两个形参。

使用一个int形参的函数和使用两个double形参的函数是可行的，它们都能用一个实参调用。其中最后那个函数本应该接受两个double值，但是因为它含有一个默认实参，所以只用一个实参也能调用它。

> 如果函数含有默认实参，则我们在调用函数时传入的实参数量可能少于它实际使用的实参数量。

在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否与形参匹配。和一般的函数调用类似，实参与形参匹配的含义可能是它们具有相同的类型，也可能是实参类型和形参类型满足转换规则。

在上面的例子中，剩下的两个函数都是可行的：

* f(int)是可行的，因为实参类型double能转换成形参类型int。
* f(double, double)是可行的，因为它的第二个形参提供了默认值，而第一个形参的类型正好是double，与函数使用的实参类型完全一致。

> 如果没找到可行函数，编译器将报告无匹配函数的错误。

### 寻找最佳匹配

函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。实参类型与形参类型越接近，它们匹配的越好。

在我们的例子中，调用只提供了一个（显式的）实参，它的类型是double。如果调用f(int)，实参将不得不从double转换成int。另一个可行函数f(double, double)则与实参精确匹配。精确匹配比需要类型转换的匹配更好，因此，编译器把f(5.6)解析成对含有两个double形参的函数的调用，并使用默认值填补我们未提供的第二个实参。

### 含有多个形参的函数匹配

当实参的数量有两个或更多时，函数匹配就比较复杂了。对于前面那些名为f的函数，我们来分析如下的调用会发生什么情况：

(42, 2.56);

选择可行函数的方法和只有一个实参时一样，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。
此例中，可行函数包括f(int, int)和f(double, double)。
接下来，编译器依次检查每个实参以确定哪个函数是最佳匹配。
如果有且只有一个函数满足下列条件，则匹配成功：
* 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。
* 至少有一个实参的匹配优于其他可行函数提供的匹配。

如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。

在上面的调用中，只考虑第一个实参时我们发现函数f(int, int)能精确匹配；要想匹配第二个函数，int类型的实参必须转换成double类型。显然需要内置类型转换的匹配劣于精确匹配，因此仅就第一个实参来说，f(int, int)比f(double, double)更好。

接着考虑第二个实参2.56，此时f(double, double)是精确匹配；要想调用f(int, int)必须将2.56从double类型转换成int类型。因此仅就第二个实参来说，f(double, double)更好。

编译器最终将因为这个调用具有二义性而拒绝其请求：因为每个可行函数各自在一个实参上实现了更好的匹配，从整体上无法判断孰优孰劣。看起来我们似乎可以通过强制类型转换其中的一个实参来实现函数的匹配，但是在设计良好的系统中，不应该对实参进行强制类型转换。

> 调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

## 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：
1. 精确匹配， 包括以下情况：
    * 实参类型和形参类型相同。
    * 实参从数组类型或函数类型转换成对应的指针类型。
    * 向实参添加顶层const或者从实参中删除顶层const。
2. 通过const转换实现的匹配。
3. 通过类型提升实现的匹配。
4. 通过算术类型转换或指针转换实现的匹配。
5. 通过类类型转换实现的匹配。

### 需要类型提升和算术类型转换的匹配

> 内置类型的提升和转换可能在函数匹配时产生意想不到的结果，但幸运的是，在设计良好的系统中函数很少会含有与下面例子类似的形参。

分析函数调用前，我们应该知道小整型一般都会提升到int类型或更大的整数类型。

假设有两个函数，一个接受int、另一个接受short，则只有当调用提供的是short类型的值时才会选择short版本的函数。有时候，即使实参是一个很小的数值，也会直接将它提升成int类型：此时使用short版本反而会导致类型转换：

```C++
void ff(int);
void ff(short);
ff('a'); //char提升成int;调用f(int)
```

所有算术类型转换的级别都一样。
例如，从int向unsigned int的转换并不比从int向double的转换级别高。
举个具体点的例子，考虑：

```C++
void mainp(long);
void mainp(float);
mainip(3.14); //错误：二义性调用
```

字面值3.14的类型是double，它既能转换成long也能转换成float。因为存在两种可能的算术类型转换，所以该调用具有二义性。

### 函数匹配和const实参

如果重载函数的区别在于他们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数：

```C++
Record lookup(Account&); //函数的参数是Account的引用
Record lookup(const Account&); //函数的参数是一个对常量的引用
const Account a;
Account b;

lookup(a); //调用lookup(const Account&)
lookup(b); //调用lookup(Account&)
```

在第一个调用中，我们传入的是const对象a。
因为不能把普通引用绑定到const对象上，所以此例中唯一可行的函数是以常量引用作为形参的那个函数，并且调用该函数与实参a精切匹配。

在第二个调用中，我们传入的是非常量对象b。
对于这个调用来说，两个函数都是可行的，因为我们即可以使用b初始化常量引用也可以用它初始化非常量引用。然而，用非常量对象初始化常量引用需要类型转换，接收非常量形参的版本则与b精确匹配。因此，应该选用非常量版本的函数。

指针类型的形参也类似。如果两个函数的唯一区别是它的指针形参指向常量或非常量，则编译器能通过实参是否是常量决定选用哪个函数：如果实参是指向常量的指针，调用形参是const*的函数；如果实参是指向非常量的指针，调用形参是普通指针的函数。

# 函数指针

函数指针指向的是函数而非对象。
函数指针指向某种特定类型。
函数的类型由它的返回类型和形参类型共同决定，与函数名无关。

例如：

```C++
// 比较两个string对象的长度
bool lengthCompare(const string &, const string &);
```

该函数的类型是bool(const string&, const string&)。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：

```C++
// pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型
bool (*pf) (const string &, const string &); //未初始化
```

从我们声明的名字开始观察，pf前面有个*，因此pf是指针；
右侧是形参列表，表示pf指向的是函数；
再观察左侧，发现函数的返回类型是布尔值。
因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。

> `*pf`两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数。

### 使用函数指针

当我们把函数名作为一个值使用时，该函数自动的转换成指针。
例如，按照如下形式我们可以将lengthCompare的地址赋给pf。

```C++
pf = lengthCompare; //pf指向名为lengthCompare的函数
pf = &lengthCompare;//等价的赋值语句：取地址符是可选的
```

此外，我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针。

```C++
bool b1 = pf("hello", "goodbye"); //调用lengthCompare函数
bool b2 = (*pf) ("hello", "goodbye"); //一个等价的调用
bool b3 = lengthCompare("hello", "goodbye"); //另一个等价的调用
```

在指向不同函数类型的指针间不存在转换规则。
但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何一个函数。

```C++
string::size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0; //正确：pf不指向任何函数
pf = sumLength; //错误：返回类型不匹配
pf = cstringCompare; //错误：形参类型不匹配
pf = lengthCompare; //正确：函数和指针的类型精确匹配
```

### 重载函数的指针

当我们使用重载函数时，上下文必须清晰的界定到底应该选用哪个函数。如果定义了指向重载函数的指针

```C++
void ff(int*);
void ff(unsigned int);

void (*pf1) (unsigned int) = ff; //pf1指向ff(unsigned)
```

编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。

```C++
void (*pf2) (int) = ff; //错误：没有任何一个ff与该形参列表匹配
double (*pf3) (int *) = ff; //错误：ff和pf3的返回类型不匹配
```

### 函数指针形参

和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。
此时，形参看起来是函数类型，实际上却是当成指针使用：

```C++
//第三个形参是函数类型，它会自动的转换成指向函数的指针
void useBigger(const string &s1, const string &s2, bool pf(const string&, const string &));

//等价的声明：显式的将形参定义成指向函数的指针
void useBigger(const string &s1, const string &s2, bool (*pf) (const string &, const string &));
```

我们可以直接把函数作为实参调用，此时它会自动转换成指针

```C++
//自动将函数lengthCompare转换成指向该函数的指针
useBigger(s1 ,s2, lengthCompare);
```

正如useBigger的声明语句所示，直接使用函数指针类型显得冗长而烦琐。类型别名和decltype能让我们简化使用了函数指针的代码

```C++
//Func和Func2是函数类型
typedef bool Func(const string&, const string&);
typedef decltype(lengthCompare) Func2; //等价的类型
//FuncP和FuncP2是指向函数的指针
typedef bool (*FuncP) (const string&, const string&);
typedef decltype(lengthCompare) *FuncP2; //等价的类型
```

我们使用typedef定义自己的类型。
Func和Func2是函数类型，而FuncP和FuncP2是指针类型。
需要注意的是，decltype返回函数类型，此时不会将函数类型自动转换成指针类型。
因为decltype的结果是函数类型，所以只有在结果前面加上*才能得到指针。

可以使用如下的形式重新声明useBigger：

```C++
//useBigger的等价声明，其中使用了类型别名
void useBigger(const string&, const string&, Func);
void useBigger(const string&, const string&, FuncP2);
```

这两个声明语句声明的是同一个函数，在第一条语句中，编译器自动的将Func表示的函数类型转换成指针。

### 返回指向函数的指针

和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。
然而，我们必须把返回类型写成指针形式，编译器不会自动的将函数返回类型当成对应的指针类型处理。
与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名：

```C++
using F = int(int*, int); //F是函数类型，不是指针
using PF = int (*) (int*, int); //PF是指针类型
```

其中我们使用类型别名将F定义成函数类型，将PF定义成指向函数类型的指针。
必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动的转换成指针。我们必须显示的将返回类型指定为指针：

```C++
PF f1(int); //正确：PF是指向函数的指针，f1返回指向函数的指针
F f1(int); //错误：F是函数类型，f1不能返回一个函数
F *f1(int); //正确：显式的指定返回类型是指向函数的指针
```

当然，我们也能用下面的形式直接声明f1：

```C++
int (*f1(int)) (int*, int);
```

按照由内向外的顺序阅读这条声明语句：我们看到f1有形参列表，所以f1是个函数；
f1前面有*，所以f1返回一个指针；
进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int。

我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数。

```C++
auto f1(int) -> int (*)(int*, int);
```

### 将auto和decltype用于函数指针类型

如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。
例如假设有两个函数，他们的返回类型都是string::size_type，并且各有两个const string&类型的形参，此时我们可以编写第三个函数，它接受一个string类型的参数，返回一个指针，该指针指向前两个函数中的一个：

```C++
string::size_type sumLength(const string&, const string&);
string::size_type largeLength(const string&, const string&);
//根据其形参的取值，getFcn函数返回指向sumLength或者largerLength的指针
decltype(sumLength) *getFcn(const string &);
```

声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。
因此，我们显式的加上*以表明我们需要返回指针，而非函数本身。

