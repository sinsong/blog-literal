---
title: C++ C 风格字符串
date: 2018-07-20 00:57:17
tags:
- C++
---

尽管C++支持C风格字符串，但是在C++程序中最好不要使用它们。这是因为C风格字符串不仅使用起来不方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。

字符串字面值是一种通用结构的实例，这种结构是C++继承C的C风格字符串(C-style character string)。
C风格字符串不是一种类型，而是为了表达和使用字符串而形成的约定俗成的写法。
约定的有字符串存放在字符数组中要以空字符结束(null terminated)。以空字符结束的意思是字符串最后一个字符后面跟着一个空字符(`\0`)。一般利用指针来操作这些字符串。

注意：空字符结束是非常重要的约定！！！不然库函数无法判断字符串在哪结束。
你给他长度了吗？不好意思，形参里头没说要长度，乖乖的以空字符结束吧！

# C标准库String函数

这些函数用来操作C风格字符串，定义在`<cstring>`中。

strlen(p)
返回p的长度，空字符不计算在内

strcmp(p1, p2)
比较p1,p2。如果p1==p2，返回0.如果p1>p2,返回一个正值。如果p1 < p2，返回一个负值。

strcat(p1,p2)
将p2附加到p1之后，返回p1。

strcpy(p1,p2)
将p2拷贝给p1，返回p1。

> 这些函数不负责验证其字符串参数。

传给这类函数的指针必须指向遵守约定的C风格字符串！
必须！严格的以空字符作为结束！

```C++
char ca[] = {'C', '+', '+'};
strlen(ca); //严重错误：ca没有以空字符结束
```

这个程序将产生未定义的结果。strlen函数将有可能沿着ca在内存中的位置，不断向下查找，知道遇到空字符才停下来。
或者访问到不该访问的区域，然后被系统干掉。

# 比较字符串

C风格字符串的话，直接拿来用，实际比较的是指针，而且没有意义。

```C++
const char ca1[] = "string";
const char ca2[] = "String";
if (ca1 < ca2) //未定义行为，比较两个无关地址
```

要比较两C风格字符串，需要调用strcmp函数，标准库为你准备好了。
它就是专门为比较字符串而设计的。

# 目标字符串的大小由调用者指定

连接或拷贝C风格字符串与std::string对象的同类操作差别很大。
使用strcat和strcpy。
不过必须提供一个用于存放结果的字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的空字符。

```C++
strcpy(largeStr, ca1);
strcat(largeStr, " "); //给largeStr末尾加一个空格
strcat(largeStr, ca2);
```

一个潜在的问题是，我们在估算largeStr所需的空间时不容易估准，而且改变内容的时候，还得重新检查其空间是否足够。
这类代码充满了风险而且经常导致严重的安全漏洞。

> 大多数应用来说，使用标准库std::string要比使用C风格字符串更安全，刚高效。
