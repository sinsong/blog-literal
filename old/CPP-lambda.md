---
title: C++ lambda表达式
date: 2018-08-07 00:19:11
tags:
- C++
---

# 介绍lambda

我们可以向一个算法传递任何类别的可调用对象(callable object)。对于一个对象或表达式，如果可以对其使用调用运算符，则称它为可调用的。
我们目前只学过函数和函数指针。
还有两种就是重载了调用运算符的类，以及lambda表达式(lambda expression)。

一个lambda表达式表示一个可调用的代码单元。
我们可以将其理解为一个未命名的内联函数。
与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。
但与函数不同，lambda可能定义在函数的内部。

一个lambda表达式具有如下形式：

[capture list] (parameter list) -> return type { function body }

其中，capture list捕获列表是一个lambda所在函数中定义的局部变量的列表（通常为空）；return type，parameter list，function body与任何普通函数一样，分别表示返回类型、参数列表和函数体。
但是，与普通函数不同，lambda必须使用尾置返回来指定返回类型。

我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体

```C++
auto f = [] { return 42; };
```

我么定义了一个可调用对象f，它不接受参数，返回42.

lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符。

```C++
f();
```

lambda中忽略括号和参数列表等价于指定一个空参数列表。
如果忽略返回类型，lambda根据函数体中的代码推断出返回类型。
如果函数体只是一个return语句，则返回类型从返回的表达式的类型推断而来。否则，返回类型为void。

> 如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。

### 向lambda传递参数

与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，lambda不能有默认参数。因此，一个lambda调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。

例子：
```C++
[](const string &a, const string &b)
{ return a.size() < b.size(); }
```

空捕获列表表明此lambda不使用他所在函数中的任意局部变量。

### 使用捕获列表

虽然一个lambda可以出现在一个函数中，使用其局部变量，但他只能使用那些明确指明的变量。
一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。
捕获列表指引lambda在其内部包含访问局部变量所需的信息。

其函数体将会以[]开始，我们可以在其中提供一个以都好分隔的名字列表，这些名字都是它所在函数中定义的。

> 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。

# lambda捕获和返回

当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就时此编译器生成的类类型的未命名对象。
类似的，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。

默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象的创建时被初始化。

## 值捕获

类似参数传递，变量的捕获方式也可以是值或引用。
值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值实在lambda创建时拷贝，而不是调用时拷贝！！！

```C++
void fcn1()
{
    size_t v1 = 42; //局部变量
    //将v1拷贝到名为f的可调用对象
    auto f = [v1] {return v1;};
    v1 = 0;
    auto j = f(); //j为42；f保存了我们创建它时v1的拷贝
}
```

由于被捕获变量的值是在lambda创建时拷贝，因此随后对其修改不会影响到lambda内对应的值。

## 引用捕获

```C++
void fcn2()
{
    size_t v1 = 42; //局部变量
    //对象f2包含v1的引用
    auto f2 = [&v1] {return v1;};
    v1 = 0;
    auto j = f2(); //j为0；f2保存v1的引用，而非拷贝
}
```

v1之前的&指出v1应该以引用方式捕获。
一个以引用方式捕获的变量与其他任何类型的引用的行为相似。
当我们在lambda函数体内使用此变量时，实际上使用的是引用绑定的对象。

引用捕获与返回引用有着相同的问题和限制。
如果我们采用引用方式捕获一个变量，就必须确保引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。

> 当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。

## 隐式捕获

除了显式列出我们希望使用的来自所在函数的变量外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。
为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。
&告诉编译器采用捕获引用的方式，=则表示采用值捕获方式。

```C++
[=](...){...}
```

如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获。
[&, c]
[=, o]

当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=。此符号指定了默认捕获方式为引用或值。

当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不用的方式。
即，如果隐式捕获时引用方式，则显式捕获命名变量必须采用值方式，因此不能再其名字前使用&。

lambda捕获列表：
[]
空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有捕获变量后才能使用它们。

[names]
names是一个逗号分隔的名字列表，这些名字都是lambda所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝。名字前如果使用了&，则采取引用捕获方式。

[&]
隐式捕获列表，采用引用捕获方式。lambda体中所使用的来自所在函数的实体都采用引用方式使用。

[=]
隐式捕获列表，采用值捕获方式。lambda体将拷贝所使用的来自所在函数的实体的值。

[&, identifier_list]
identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。identifier_list中的名字前面不能使用&。

[=, identifier_list]
identifier_list中的变量都采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。identifier_list中的名字不能包括this，且这些名字之前必须使用&。

## 可变lambda

默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须再参数列表首加上关键字`mutable`。因此，可变lambda能省略参数列表。

```C++
void fcn3()
{
    size_t v1 = 42; //局部变量
    // f可以改变它所捕获的变量的值
    auto f = [v1] () mutable { return ++v1; };
    v1 = 0;
    auto j = f(); //j为43
}
```

一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型。

```C++
void fcn4()
{
    size_t v1 = 42; //局部变量
    //v1是一个非const变量的引用
    //可以通过f2中的引用来改变它
    auto f2 = [&v1] {return ++v1;};
    v1 = 0;
    auto j = f2(); //j改为1
}
```

## 指定lambda返回类型

默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。与其他返回void的函数类似，被推断返回void的lambda不能返回值。

当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型。

```C++
[](...) -> T {...}
```

